/*
 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { __decorate } from "tslib";
import classNames from "classnames";
import * as React from "react";
import { polyfill } from "react-lifecycles-compat";
import { AbstractPureComponent2, DISPLAYNAME_PREFIX, getRef, InputGroup, Intent, isRefObject, Keys, Popover, } from "@blueprintjs/core";
import * as Classes from "./common/classes";
import { isDateValid, isDayInRange } from "./common/dateUtils";
import { getFormattedDateString } from "./dateFormat";
import { DatePicker } from "./datePicker";
import { getDefaultMaxDate, getDefaultMinDate } from "./datePickerCore";
let DateInput = class DateInput extends AbstractPureComponent2 {
    constructor() {
        super(...arguments);
        this.state = {
            isInputFocused: false,
            isOpen: false,
            value: this.props.value !== undefined ? this.props.value : this.props.defaultValue,
            valueString: null,
        };
        this.inputEl = null;
        this.popoverContentEl = null;
        // Last element in popover that is tabbable, and the one that triggers popover closure
        // when the user press TAB on it
        this.lastTabbableElement = null;
        this.refHandlers = {
            input: isRefObject(this.props.inputProps?.inputRef)
                ? (this.inputEl = this.props.inputProps.inputRef)
                : (ref) => {
                    this.inputEl = ref;
                    this.props.inputProps?.inputRef?.(ref);
                },
        };
        this.handleClosePopover = (e) => {
            const { popoverProps = {} } = this.props;
            popoverProps.onClose?.(e);
            this.setState({ isOpen: false });
        };
        this.handleDateChange = (newDate, isUserChange, didSubmitWithEnter = false) => {
            const prevDate = this.state.value;
            // this change handler was triggered by a change in month, day, or (if
            // enabled) time. for UX purposes, we want to close the popover only if
            // the user explicitly clicked a day within the current month.
            const isOpen = !isUserChange ||
                !this.props.closeOnSelection ||
                (prevDate != null && (this.hasMonthChanged(prevDate, newDate) || this.hasTimeChanged(prevDate, newDate)));
            // if selecting a date via click or Tab, the input will already be
            // blurred by now, so sync isInputFocused to false. if selecting via
            // Enter, setting isInputFocused to false won't do anything by itself,
            // plus we want the field to retain focus anyway.
            // (note: spelling out the ternary explicitly reads more clearly.)
            const isInputFocused = didSubmitWithEnter ? true : false;
            if (this.props.value === undefined) {
                const valueString = getFormattedDateString(newDate, this.props);
                this.setState({ isInputFocused, isOpen, value: newDate, valueString });
            }
            else {
                this.setState({ isInputFocused, isOpen });
            }
            this.props.onChange?.(newDate, isUserChange);
        };
        this.handleInputFocus = (e) => {
            const valueString = this.state.value == null ? "" : this.formatDate(this.state.value);
            this.setState({ isInputFocused: true, isOpen: true, valueString });
            this.safeInvokeInputProp("onFocus", e);
        };
        this.handleInputClick = (e) => {
            // stop propagation to the Popover's internal handleTargetClick handler;
            // otherwise, the popover will flicker closed as soon as it opens.
            e.stopPropagation();
            this.safeInvokeInputProp("onClick", e);
        };
        this.handleInputChange = (e) => {
            const valueString = e.target.value;
            const value = this.parseDate(valueString);
            if (isDateValid(value) && this.isDateInRange(value)) {
                if (this.props.value === undefined) {
                    this.setState({ value, valueString });
                }
                else {
                    this.setState({ valueString });
                }
                this.props.onChange?.(value, true);
            }
            else {
                if (valueString.length === 0) {
                    this.props.onChange?.(null, true);
                }
                this.setState({ valueString });
            }
            this.safeInvokeInputProp("onChange", e);
        };
        this.handleInputBlur = (e) => {
            const { valueString } = this.state;
            const date = this.parseDate(valueString);
            if (valueString.length > 0 &&
                valueString !== getFormattedDateString(this.state.value, this.props) &&
                (!isDateValid(date) || !this.isDateInRange(date))) {
                if (this.props.value === undefined) {
                    this.setState({ isInputFocused: false, value: date, valueString: null });
                }
                else {
                    this.setState({ isInputFocused: false });
                }
                if (isNaN(date.valueOf())) {
                    this.props.onError?.(new Date(undefined));
                }
                else if (!this.isDateInRange(date)) {
                    this.props.onError?.(date);
                }
                else {
                    this.props.onChange?.(date, true);
                }
            }
            else {
                if (valueString.length === 0) {
                    this.setState({ isInputFocused: false, value: null, valueString: null });
                }
                else {
                    this.setState({ isInputFocused: false });
                }
            }
            this.registerPopoverBlurHandler();
            this.safeInvokeInputProp("onBlur", e);
        };
        this.handleInputKeyDown = (e) => {
            // HACKHACK: https://github.com/palantir/blueprint/issues/4165
            /* eslint-disable deprecation/deprecation */
            if (e.which === Keys.ENTER) {
                const nextDate = this.parseDate(this.state.valueString);
                this.handleDateChange(nextDate, true, true);
            }
            else if (e.which === Keys.TAB) {
                this.setState({ isOpen: false });
            }
            else if (e.which === Keys.ESCAPE) {
                this.setState({ isOpen: false });
                getRef(this.inputEl).blur();
            }
            this.safeInvokeInputProp("onKeyDown", e);
        };
        this.getLastTabbableElement = () => {
            // Popover contents are well structured, but the selector will need
            // to be updated if more focusable components are added in the future
            const tabbableElements = this.popoverContentEl.querySelectorAll("input, [tabindex]:not([tabindex='-1'])");
            const numOfElements = tabbableElements.length;
            // Keep track of the last focusable element in popover and add
            // a blur handler, so that when:
            // * user tabs to the next element, popover closes
            // * focus moves to element within popover, popover stays open
            const lastTabbableElement = numOfElements > 0 ? tabbableElements[numOfElements - 1] : null;
            return lastTabbableElement;
        };
        // focus DOM event listener (not React event)
        this.handlePopoverBlur = (e) => {
            let relatedTarget = e.relatedTarget;
            if (relatedTarget == null) {
                // Support IE11 (#2924)
                relatedTarget = document.activeElement;
            }
            const eventTarget = e.target;
            // Beware: this.popoverContentEl is sometimes null under Chrome
            if (relatedTarget == null ||
                (this.popoverContentEl != null && !this.popoverContentEl.contains(relatedTarget))) {
                // Exclude the following blur operations that makes "body" the activeElement
                // and would close the Popover unexpectedly
                // - On disabled change months buttons
                // - DayPicker day elements, their "blur" will be managed at its own onKeyDown
                const isChangeMonthEvt = eventTarget.classList.contains(Classes.DATEPICKER_NAVBUTTON);
                const isChangeMonthButtonDisabled = isChangeMonthEvt && eventTarget.disabled;
                const isDayPickerDayEvt = eventTarget.classList.contains(Classes.DATEPICKER_DAY);
                if (!isChangeMonthButtonDisabled && !isDayPickerDayEvt) {
                    this.handleClosePopover();
                }
            }
            else if (relatedTarget != null) {
                this.unregisterPopoverBlurHandler();
                this.lastTabbableElement = this.getLastTabbableElement();
                this.lastTabbableElement.addEventListener("blur", this.handlePopoverBlur);
            }
        };
        this.registerPopoverBlurHandler = () => {
            if (this.popoverContentEl != null) {
                this.unregisterPopoverBlurHandler();
                this.lastTabbableElement = this.getLastTabbableElement();
                this.lastTabbableElement.addEventListener("blur", this.handlePopoverBlur);
            }
        };
        this.unregisterPopoverBlurHandler = () => {
            if (this.lastTabbableElement != null) {
                this.lastTabbableElement.removeEventListener("blur", this.handlePopoverBlur);
            }
        };
        this.handleShortcutChange = (_, selectedShortcutIndex) => {
            this.setState({ selectedShortcutIndex });
        };
    }
    componentWillUnmount() {
        this.unregisterPopoverBlurHandler();
    }
    render() {
        const { value, valueString } = this.state;
        const dateString = this.state.isInputFocused ? valueString : getFormattedDateString(value, this.props);
        const dateValue = isDateValid(value) ? value : null;
        const dayPickerProps = {
            ...this.props.dayPickerProps,
            // If the user presses the TAB key on a DayPicker Day element and the lastTabbableElement is also a DayPicker Day
            // element, the popover should be closed
            onDayKeyDown: (day, modifiers, e) => {
                if (e.key === "Tab" &&
                    !e.shiftKey &&
                    this.lastTabbableElement.classList.contains(Classes.DATEPICKER_DAY)) {
                    this.setState({ isOpen: false });
                }
                this.props.dayPickerProps.onDayKeyDown?.(day, modifiers, e);
            },
            // dom elements for the updated month is not available when
            // onMonthChange is called. setTimeout is necessary to wait
            // for the updated month to be rendered
            onMonthChange: (month) => {
                this.props.dayPickerProps.onMonthChange?.(month);
                this.setTimeout(this.registerPopoverBlurHandler);
            },
        };
        const wrappedPopoverContent = (React.createElement("div", { ref: ref => (this.popoverContentEl = ref) },
            React.createElement(DatePicker, Object.assign({}, this.props, { dayPickerProps: dayPickerProps, onChange: this.handleDateChange, value: dateValue, onShortcutChange: this.handleShortcutChange, selectedShortcutIndex: this.state.selectedShortcutIndex }))));
        // assign default empty object here to prevent mutation
        const { inputProps = {}, popoverProps = {} } = this.props;
        const isErrorState = value != null && (!isDateValid(value) || !this.isDateInRange(value));
        return (React.createElement(Popover, Object.assign({ isOpen: this.state.isOpen && !this.props.disabled, fill: this.props.fill }, popoverProps, { autoFocus: false, className: classNames(popoverProps.className, this.props.className), content: wrappedPopoverContent, enforceFocus: false, onClose: this.handleClosePopover, popoverClassName: classNames(Classes.DATEINPUT_POPOVER, popoverProps.popoverClassName) }),
            React.createElement(InputGroup, Object.assign({ autoComplete: "off", intent: isErrorState ? Intent.DANGER : Intent.NONE, placeholder: this.props.placeholder, rightElement: this.props.rightElement, type: "text" }, inputProps, { disabled: this.props.disabled, inputRef: this.refHandlers.input, onBlur: this.handleInputBlur, onChange: this.handleInputChange, onClick: this.handleInputClick, onFocus: this.handleInputFocus, onKeyDown: this.handleInputKeyDown, value: dateString }))));
    }
    componentDidUpdate(prevProps, prevState) {
        super.componentDidUpdate(prevProps, prevState);
        if (prevProps.value !== this.props.value) {
            this.setState({ value: this.props.value });
        }
    }
    isDateInRange(value) {
        return isDayInRange(value, [this.props.minDate, this.props.maxDate]);
    }
    hasMonthChanged(prevDate, nextDate) {
        return (prevDate == null) !== (nextDate == null) || nextDate.getMonth() !== prevDate.getMonth();
    }
    hasTimeChanged(prevDate, nextDate) {
        if (this.props.timePrecision == null) {
            return false;
        }
        return ((prevDate == null) !== (nextDate == null) ||
            nextDate.getHours() !== prevDate.getHours() ||
            nextDate.getMinutes() !== prevDate.getMinutes() ||
            nextDate.getSeconds() !== prevDate.getSeconds() ||
            nextDate.getMilliseconds() !== prevDate.getMilliseconds());
    }
    /** safe wrapper around invoking input props event handler (prop defaults to undefined) */
    safeInvokeInputProp(name, e) {
        const { inputProps = {} } = this.props;
        inputProps[name]?.(e);
    }
    parseDate(dateString) {
        if (dateString === this.props.outOfRangeMessage || dateString === this.props.invalidDateMessage) {
            return null;
        }
        const { locale, parseDate } = this.props;
        const newDate = parseDate(dateString, locale);
        return newDate === false ? new Date(undefined) : newDate;
    }
    formatDate(date) {
        if (!isDateValid(date) || !this.isDateInRange(date)) {
            return "";
        }
        const { locale, formatDate } = this.props;
        return formatDate(date, locale);
    }
};
DateInput.displayName = `${DISPLAYNAME_PREFIX}.DateInput`;
DateInput.defaultProps = {
    closeOnSelection: true,
    dayPickerProps: {},
    disabled: false,
    invalidDateMessage: "Invalid date",
    maxDate: getDefaultMaxDate(),
    minDate: getDefaultMinDate(),
    outOfRangeMessage: "Out of range",
    reverseMonthAndYearMenus: false,
};
DateInput = __decorate([
    polyfill
], DateInput);
export { DateInput };
//# sourceMappingURL=dateInput.js.map