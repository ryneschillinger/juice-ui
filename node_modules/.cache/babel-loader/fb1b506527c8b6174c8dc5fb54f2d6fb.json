{"ast":null,"code":"/*\n * Copyright 2018 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { clamp } from \"../../common/utils\";\n/** Returns the `decimal` number separator based on locale */\n\nfunction getDecimalSeparator(locale) {\n  var testNumber = 1.9;\n  var testText = testNumber.toLocaleString(locale);\n  var one = 1 .toLocaleString(locale);\n  var nine = 9 .toLocaleString(locale);\n  var pattern = one + \"(.+)\" + nine;\n  var result = new RegExp(pattern).exec(testText);\n  return result && result[1] || \".\";\n}\n\nexport function toLocaleString(num, locale) {\n  if (locale === void 0) {\n    locale = \"en-US\";\n  }\n\n  return sanitizeNumericInput(num.toLocaleString(locale), locale);\n}\nexport function clampValue(value, min, max) {\n  // defaultProps won't work if the user passes in null, so just default\n  // to +/- infinity here instead, as a catch-all.\n  var adjustedMin = min != null ? min : -Infinity;\n  var adjustedMax = max != null ? max : Infinity;\n  return clamp(value, adjustedMin, adjustedMax);\n}\nexport function getValueOrEmptyValue(value) {\n  if (value === void 0) {\n    value = \"\";\n  }\n\n  return value.toString();\n}\n/** Transform the localized character (ex. \"\") to a javascript recognizable string number (ex. \"10.99\")  */\n\nfunction transformLocalizedNumberToStringNumber(character, locale) {\n  var charactersMap = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(function (value) {\n    return value.toLocaleString(locale);\n  });\n  var jsNumber = charactersMap.indexOf(character);\n\n  if (jsNumber !== -1) {\n    return jsNumber;\n  } else {\n    return character;\n  }\n}\n/** Transforms the localized number (ex. \"10,99\") to a javascript recognizable string number (ex. \"10.99\")  */\n\n\nexport function parseStringToStringNumber(value, locale) {\n  var valueAsString = \"\" + value;\n\n  if (parseFloat(valueAsString).toString() === value.toString()) {\n    return value.toString();\n  }\n\n  if (locale !== undefined) {\n    var decimalSeparator = getDecimalSeparator(locale);\n    var sanitizedString = sanitizeNumericInput(valueAsString, locale);\n    return sanitizedString.split(\"\").map(function (character) {\n      return transformLocalizedNumberToStringNumber(character, locale);\n    }).join(\"\").replace(decimalSeparator, \".\");\n  }\n\n  return value.toString();\n}\n/** Returns `true` if the string represents a valid numeric value, like \"1e6\". */\n\nexport function isValueNumeric(value, locale) {\n  // checking if a string is numeric in Typescript is a big pain, because\n  // we can't simply toss a string parameter to isFinite. below is the\n  // essential approach that jQuery uses, which involves subtracting a\n  // parsed numeric value from the string representation of the value. we\n  // need to cast the value to the `any` type to allow this operation\n  // between dissimilar types.\n  var stringToStringNumber = parseStringToStringNumber(value, locale);\n  return value != null && stringToStringNumber - parseFloat(stringToStringNumber) + 1 >= 0;\n}\nexport function isValidNumericKeyboardEvent(e, locale) {\n  // unit tests may not include e.key. don't bother disabling those events.\n  if (e.key == null) {\n    return true;\n  } // allow modified key strokes that may involve letters and other\n  // non-numeric/invalid characters (Cmd + A, Cmd + C, Cmd + V, Cmd + X).\n\n\n  if (e.ctrlKey || e.altKey || e.metaKey) {\n    return true;\n  } // keys that print a single character when pressed have a `key` name of\n  // length 1. every other key has a longer `key` name (e.g. \"Backspace\",\n  // \"ArrowUp\", \"Shift\"). since none of those keys can print a character\n  // to the field--and since they may have important native behaviors\n  // beyond printing a character--we don't want to disable their effects.\n\n\n  var isSingleCharKey = e.key.length === 1;\n\n  if (!isSingleCharKey) {\n    return true;\n  } // now we can simply check that the single character that wants to be printed\n  // is a floating-point number character that we're allowed to print.\n\n\n  return isFloatingPointNumericCharacter(e.key, locale);\n}\n/**\n * A regex that matches a string of length 1 (i.e. a standalone character)\n * if and only if it is a floating-point number character as defined by W3C:\n * https://www.w3.org/TR/2012/WD-html-markup-20120329/datatypes.html#common.data.float\n *\n * Floating-point number characters are the only characters that can be\n * printed within a default input[type=\"number\"]. This component should\n * behave the same way when this.props.allowNumericCharactersOnly = true.\n * See here for the input[type=\"number\"].value spec:\n * https://www.w3.org/TR/2012/WD-html-markup-20120329/input.number.html#input.number.attrs.value\n */\n\nfunction isFloatingPointNumericCharacter(character, locale) {\n  if (locale !== undefined) {\n    var decimalSeparator = getDecimalSeparator(locale).replace(\".\", \"\\\\.\");\n    var numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(function (value) {\n      return value.toLocaleString(locale);\n    }).join(\"\");\n    var localeFloatingPointNumericCharacterRegex = new RegExp(\"^[Ee\" + numbers + \"\\\\+\\\\-\" + decimalSeparator + \"]$\");\n    return localeFloatingPointNumericCharacterRegex.test(character);\n  } else {\n    var floatingPointNumericCharacterRegex = /^[Ee0-9\\+\\-\\.]$/;\n    return floatingPointNumericCharacterRegex.test(character);\n  }\n}\n/**\n * Round the value to have _up to_ the specified maximum precision.\n *\n * This differs from `toFixed(5)` in that trailing zeroes are not added on\n * more precise values, resulting in shorter strings.\n */\n\n\nexport function toMaxPrecision(value, maxPrecision) {\n  // round the value to have the specified maximum precision (toFixed is the wrong choice,\n  // because it would show trailing zeros in the decimal part out to the specified precision)\n  // source: http://stackoverflow.com/a/18358056/5199574\n  var scaleFactor = Math.pow(10, maxPrecision);\n  return Math.round(value * scaleFactor) / scaleFactor;\n}\n/**\n * Convert Japanese full-width numbers, e.g. 'ï¼•', to ASCII, e.g. '5'\n * This should be called before performing any other numeric string input validation.\n */\n\nfunction convertFullWidthNumbersToAscii(value) {\n  return value.replace(/[\\uFF10-\\uFF19]/g, function (m) {\n    return String.fromCharCode(m.charCodeAt(0) - 0xfee0);\n  });\n}\n/**\n * Convert full-width (Japanese) numbers to ASCII, and strip all characters that are not valid floating-point numeric characters\n */\n\n\nexport function sanitizeNumericInput(value, locale) {\n  var valueChars = convertFullWidthNumbersToAscii(value).split(\"\");\n  var sanitizedValueChars = valueChars.filter(function (valueChar) {\n    return isFloatingPointNumericCharacter(valueChar, locale);\n  });\n  return sanitizedValueChars.join(\"\");\n}","map":null,"metadata":{},"sourceType":"module"}