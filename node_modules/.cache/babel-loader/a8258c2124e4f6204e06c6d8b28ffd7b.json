{"ast":null,"code":"/*\n * Copyright 2016 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { __assign, __decorate, __extends } from \"tslib\";\nimport classNames from \"classnames\";\nimport * as React from \"react\";\nimport { polyfill } from \"react-lifecycles-compat\";\nimport { AbstractPureComponent2, DISPLAYNAME_PREFIX, getRef, InputGroup, Intent, isRefObject, Keys, Popover } from \"@blueprintjs/core\";\nimport * as Classes from \"./common/classes\";\nimport { isDateValid, isDayInRange } from \"./common/dateUtils\";\nimport { getFormattedDateString } from \"./dateFormat\";\nimport { DatePicker } from \"./datePicker\";\nimport { getDefaultMaxDate, getDefaultMinDate } from \"./datePickerCore\";\n\nvar DateInput =\n/** @class */\nfunction (_super) {\n  __extends(DateInput, _super);\n\n  function DateInput() {\n    var _a;\n\n    var _this = _super.apply(this, arguments) || this;\n\n    _this.state = {\n      isInputFocused: false,\n      isOpen: false,\n      value: _this.props.value !== undefined ? _this.props.value : _this.props.defaultValue,\n      valueString: null\n    };\n    _this.inputEl = null;\n    _this.popoverContentEl = null; // Last element in popover that is tabbable, and the one that triggers popover closure\n    // when the user press TAB on it\n\n    _this.lastTabbableElement = null;\n    _this.refHandlers = {\n      input: isRefObject((_a = _this.props.inputProps) === null || _a === void 0 ? void 0 : _a.inputRef) ? _this.inputEl = _this.props.inputProps.inputRef : function (ref) {\n        var _a, _b;\n\n        _this.inputEl = ref;\n        (_b = (_a = _this.props.inputProps) === null || _a === void 0 ? void 0 : _a.inputRef) === null || _b === void 0 ? void 0 : _b(ref);\n      }\n    };\n\n    _this.handleClosePopover = function (e) {\n      var _a;\n\n      var _b = _this.props.popoverProps,\n          popoverProps = _b === void 0 ? {} : _b;\n      (_a = popoverProps.onClose) === null || _a === void 0 ? void 0 : _a.call(popoverProps, e);\n\n      _this.setState({\n        isOpen: false\n      });\n    };\n\n    _this.handleDateChange = function (newDate, isUserChange, didSubmitWithEnter) {\n      var _a, _b;\n\n      if (didSubmitWithEnter === void 0) {\n        didSubmitWithEnter = false;\n      }\n\n      var prevDate = _this.state.value; // this change handler was triggered by a change in month, day, or (if\n      // enabled) time. for UX purposes, we want to close the popover only if\n      // the user explicitly clicked a day within the current month.\n\n      var isOpen = !isUserChange || !_this.props.closeOnSelection || prevDate != null && (_this.hasMonthChanged(prevDate, newDate) || _this.hasTimeChanged(prevDate, newDate)); // if selecting a date via click or Tab, the input will already be\n      // blurred by now, so sync isInputFocused to false. if selecting via\n      // Enter, setting isInputFocused to false won't do anything by itself,\n      // plus we want the field to retain focus anyway.\n      // (note: spelling out the ternary explicitly reads more clearly.)\n\n\n      var isInputFocused = didSubmitWithEnter ? true : false;\n\n      if (_this.props.value === undefined) {\n        var valueString = getFormattedDateString(newDate, _this.props);\n\n        _this.setState({\n          isInputFocused: isInputFocused,\n          isOpen: isOpen,\n          value: newDate,\n          valueString: valueString\n        });\n      } else {\n        _this.setState({\n          isInputFocused: isInputFocused,\n          isOpen: isOpen\n        });\n      }\n\n      (_b = (_a = _this.props).onChange) === null || _b === void 0 ? void 0 : _b.call(_a, newDate, isUserChange);\n    };\n\n    _this.handleInputFocus = function (e) {\n      var valueString = _this.state.value == null ? \"\" : _this.formatDate(_this.state.value);\n\n      _this.setState({\n        isInputFocused: true,\n        isOpen: true,\n        valueString: valueString\n      });\n\n      _this.safeInvokeInputProp(\"onFocus\", e);\n    };\n\n    _this.handleInputClick = function (e) {\n      // stop propagation to the Popover's internal handleTargetClick handler;\n      // otherwise, the popover will flicker closed as soon as it opens.\n      e.stopPropagation();\n\n      _this.safeInvokeInputProp(\"onClick\", e);\n    };\n\n    _this.handleInputChange = function (e) {\n      var _a, _b, _c, _d;\n\n      var valueString = e.target.value;\n\n      var value = _this.parseDate(valueString);\n\n      if (isDateValid(value) && _this.isDateInRange(value)) {\n        if (_this.props.value === undefined) {\n          _this.setState({\n            value: value,\n            valueString: valueString\n          });\n        } else {\n          _this.setState({\n            valueString: valueString\n          });\n        }\n\n        (_b = (_a = _this.props).onChange) === null || _b === void 0 ? void 0 : _b.call(_a, value, true);\n      } else {\n        if (valueString.length === 0) {\n          (_d = (_c = _this.props).onChange) === null || _d === void 0 ? void 0 : _d.call(_c, null, true);\n        }\n\n        _this.setState({\n          valueString: valueString\n        });\n      }\n\n      _this.safeInvokeInputProp(\"onChange\", e);\n    };\n\n    _this.handleInputBlur = function (e) {\n      var _a, _b, _c, _d, _e, _f;\n\n      var valueString = _this.state.valueString;\n\n      var date = _this.parseDate(valueString);\n\n      if (valueString.length > 0 && valueString !== getFormattedDateString(_this.state.value, _this.props) && (!isDateValid(date) || !_this.isDateInRange(date))) {\n        if (_this.props.value === undefined) {\n          _this.setState({\n            isInputFocused: false,\n            value: date,\n            valueString: null\n          });\n        } else {\n          _this.setState({\n            isInputFocused: false\n          });\n        }\n\n        if (isNaN(date.valueOf())) {\n          (_b = (_a = _this.props).onError) === null || _b === void 0 ? void 0 : _b.call(_a, new Date(undefined));\n        } else if (!_this.isDateInRange(date)) {\n          (_d = (_c = _this.props).onError) === null || _d === void 0 ? void 0 : _d.call(_c, date);\n        } else {\n          (_f = (_e = _this.props).onChange) === null || _f === void 0 ? void 0 : _f.call(_e, date, true);\n        }\n      } else {\n        if (valueString.length === 0) {\n          _this.setState({\n            isInputFocused: false,\n            value: null,\n            valueString: null\n          });\n        } else {\n          _this.setState({\n            isInputFocused: false\n          });\n        }\n      }\n\n      _this.registerPopoverBlurHandler();\n\n      _this.safeInvokeInputProp(\"onBlur\", e);\n    };\n\n    _this.handleInputKeyDown = function (e) {\n      // HACKHACK: https://github.com/palantir/blueprint/issues/4165\n\n      /* eslint-disable deprecation/deprecation */\n      if (e.which === Keys.ENTER) {\n        var nextDate = _this.parseDate(_this.state.valueString);\n\n        _this.handleDateChange(nextDate, true, true);\n      } else if (e.which === Keys.TAB) {\n        _this.setState({\n          isOpen: false\n        });\n      } else if (e.which === Keys.ESCAPE) {\n        _this.setState({\n          isOpen: false\n        });\n\n        getRef(_this.inputEl).blur();\n      }\n\n      _this.safeInvokeInputProp(\"onKeyDown\", e);\n    };\n\n    _this.getLastTabbableElement = function () {\n      // Popover contents are well structured, but the selector will need\n      // to be updated if more focusable components are added in the future\n      var tabbableElements = _this.popoverContentEl.querySelectorAll(\"input, [tabindex]:not([tabindex='-1'])\");\n\n      var numOfElements = tabbableElements.length; // Keep track of the last focusable element in popover and add\n      // a blur handler, so that when:\n      // * user tabs to the next element, popover closes\n      // * focus moves to element within popover, popover stays open\n\n      var lastTabbableElement = numOfElements > 0 ? tabbableElements[numOfElements - 1] : null;\n      return lastTabbableElement;\n    }; // focus DOM event listener (not React event)\n\n\n    _this.handlePopoverBlur = function (e) {\n      var relatedTarget = e.relatedTarget;\n\n      if (relatedTarget == null) {\n        // Support IE11 (#2924)\n        relatedTarget = document.activeElement;\n      }\n\n      var eventTarget = e.target; // Beware: this.popoverContentEl is sometimes null under Chrome\n\n      if (relatedTarget == null || _this.popoverContentEl != null && !_this.popoverContentEl.contains(relatedTarget)) {\n        // Exclude the following blur operations that makes \"body\" the activeElement\n        // and would close the Popover unexpectedly\n        // - On disabled change months buttons\n        // - DayPicker day elements, their \"blur\" will be managed at its own onKeyDown\n        var isChangeMonthEvt = eventTarget.classList.contains(Classes.DATEPICKER_NAVBUTTON);\n        var isChangeMonthButtonDisabled = isChangeMonthEvt && eventTarget.disabled;\n        var isDayPickerDayEvt = eventTarget.classList.contains(Classes.DATEPICKER_DAY);\n\n        if (!isChangeMonthButtonDisabled && !isDayPickerDayEvt) {\n          _this.handleClosePopover();\n        }\n      } else if (relatedTarget != null) {\n        _this.unregisterPopoverBlurHandler();\n\n        _this.lastTabbableElement = _this.getLastTabbableElement();\n\n        _this.lastTabbableElement.addEventListener(\"blur\", _this.handlePopoverBlur);\n      }\n    };\n\n    _this.registerPopoverBlurHandler = function () {\n      if (_this.popoverContentEl != null) {\n        _this.unregisterPopoverBlurHandler();\n\n        _this.lastTabbableElement = _this.getLastTabbableElement();\n\n        _this.lastTabbableElement.addEventListener(\"blur\", _this.handlePopoverBlur);\n      }\n    };\n\n    _this.unregisterPopoverBlurHandler = function () {\n      if (_this.lastTabbableElement != null) {\n        _this.lastTabbableElement.removeEventListener(\"blur\", _this.handlePopoverBlur);\n      }\n    };\n\n    _this.handleShortcutChange = function (_, selectedShortcutIndex) {\n      _this.setState({\n        selectedShortcutIndex: selectedShortcutIndex\n      });\n    };\n\n    return _this;\n  }\n\n  DateInput.prototype.componentWillUnmount = function () {\n    this.unregisterPopoverBlurHandler();\n  };\n\n  DateInput.prototype.render = function () {\n    var _this = this;\n\n    var _a = this.state,\n        value = _a.value,\n        valueString = _a.valueString;\n    var dateString = this.state.isInputFocused ? valueString : getFormattedDateString(value, this.props);\n    var dateValue = isDateValid(value) ? value : null;\n\n    var dayPickerProps = __assign(__assign({}, this.props.dayPickerProps), {\n      // If the user presses the TAB key on a DayPicker Day element and the lastTabbableElement is also a DayPicker Day\n      // element, the popover should be closed\n      onDayKeyDown: function (day, modifiers, e) {\n        var _a, _b;\n\n        if (e.key === \"Tab\" && !e.shiftKey && _this.lastTabbableElement.classList.contains(Classes.DATEPICKER_DAY)) {\n          _this.setState({\n            isOpen: false\n          });\n        }\n\n        (_b = (_a = _this.props.dayPickerProps).onDayKeyDown) === null || _b === void 0 ? void 0 : _b.call(_a, day, modifiers, e);\n      },\n      // dom elements for the updated month is not available when\n      // onMonthChange is called. setTimeout is necessary to wait\n      // for the updated month to be rendered\n      onMonthChange: function (month) {\n        var _a, _b;\n\n        (_b = (_a = _this.props.dayPickerProps).onMonthChange) === null || _b === void 0 ? void 0 : _b.call(_a, month);\n\n        _this.setTimeout(_this.registerPopoverBlurHandler);\n      }\n    });\n\n    var wrappedPopoverContent = React.createElement(\"div\", {\n      ref: function (ref) {\n        return _this.popoverContentEl = ref;\n      }\n    }, React.createElement(DatePicker, __assign({}, this.props, {\n      dayPickerProps: dayPickerProps,\n      onChange: this.handleDateChange,\n      value: dateValue,\n      onShortcutChange: this.handleShortcutChange,\n      selectedShortcutIndex: this.state.selectedShortcutIndex\n    }))); // assign default empty object here to prevent mutation\n\n    var _b = this.props,\n        _c = _b.inputProps,\n        inputProps = _c === void 0 ? {} : _c,\n        _d = _b.popoverProps,\n        popoverProps = _d === void 0 ? {} : _d;\n    var isErrorState = value != null && (!isDateValid(value) || !this.isDateInRange(value));\n    return React.createElement(Popover, __assign({\n      isOpen: this.state.isOpen && !this.props.disabled,\n      fill: this.props.fill\n    }, popoverProps, {\n      autoFocus: false,\n      className: classNames(popoverProps.className, this.props.className),\n      content: wrappedPopoverContent,\n      enforceFocus: false,\n      onClose: this.handleClosePopover,\n      popoverClassName: classNames(Classes.DATEINPUT_POPOVER, popoverProps.popoverClassName)\n    }), React.createElement(InputGroup, __assign({\n      autoComplete: \"off\",\n      intent: isErrorState ? Intent.DANGER : Intent.NONE,\n      placeholder: this.props.placeholder,\n      rightElement: this.props.rightElement,\n      type: \"text\"\n    }, inputProps, {\n      disabled: this.props.disabled,\n      inputRef: this.refHandlers.input,\n      onBlur: this.handleInputBlur,\n      onChange: this.handleInputChange,\n      onClick: this.handleInputClick,\n      onFocus: this.handleInputFocus,\n      onKeyDown: this.handleInputKeyDown,\n      value: dateString\n    })));\n  };\n\n  DateInput.prototype.componentDidUpdate = function (prevProps, prevState) {\n    _super.prototype.componentDidUpdate.call(this, prevProps, prevState);\n\n    if (prevProps.value !== this.props.value) {\n      this.setState({\n        value: this.props.value\n      });\n    }\n  };\n\n  DateInput.prototype.isDateInRange = function (value) {\n    return isDayInRange(value, [this.props.minDate, this.props.maxDate]);\n  };\n\n  DateInput.prototype.hasMonthChanged = function (prevDate, nextDate) {\n    return prevDate == null !== (nextDate == null) || nextDate.getMonth() !== prevDate.getMonth();\n  };\n\n  DateInput.prototype.hasTimeChanged = function (prevDate, nextDate) {\n    if (this.props.timePrecision == null) {\n      return false;\n    }\n\n    return prevDate == null !== (nextDate == null) || nextDate.getHours() !== prevDate.getHours() || nextDate.getMinutes() !== prevDate.getMinutes() || nextDate.getSeconds() !== prevDate.getSeconds() || nextDate.getMilliseconds() !== prevDate.getMilliseconds();\n  };\n  /** safe wrapper around invoking input props event handler (prop defaults to undefined) */\n\n\n  DateInput.prototype.safeInvokeInputProp = function (name, e) {\n    var _a;\n\n    var _b = this.props.inputProps,\n        inputProps = _b === void 0 ? {} : _b;\n    (_a = inputProps[name]) === null || _a === void 0 ? void 0 : _a.call(inputProps, e);\n  };\n\n  DateInput.prototype.parseDate = function (dateString) {\n    if (dateString === this.props.outOfRangeMessage || dateString === this.props.invalidDateMessage) {\n      return null;\n    }\n\n    var _a = this.props,\n        locale = _a.locale,\n        parseDate = _a.parseDate;\n    var newDate = parseDate(dateString, locale);\n    return newDate === false ? new Date(undefined) : newDate;\n  };\n\n  DateInput.prototype.formatDate = function (date) {\n    if (!isDateValid(date) || !this.isDateInRange(date)) {\n      return \"\";\n    }\n\n    var _a = this.props,\n        locale = _a.locale,\n        formatDate = _a.formatDate;\n    return formatDate(date, locale);\n  };\n\n  DateInput.displayName = DISPLAYNAME_PREFIX + \".DateInput\";\n  DateInput.defaultProps = {\n    closeOnSelection: true,\n    dayPickerProps: {},\n    disabled: false,\n    invalidDateMessage: \"Invalid date\",\n    maxDate: getDefaultMaxDate(),\n    minDate: getDefaultMinDate(),\n    outOfRangeMessage: \"Out of range\",\n    reverseMonthAndYearMenus: false\n  };\n  DateInput = __decorate([polyfill], DateInput);\n  return DateInput;\n}(AbstractPureComponent2);\n\nexport { DateInput };","map":null,"metadata":{},"sourceType":"module"}