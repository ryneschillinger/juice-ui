{"ast":null,"code":"/*\n * Copyright 2017 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { __assign, __extends, __rest } from \"tslib\";\nimport classNames from \"classnames\";\nimport * as React from \"react\";\nimport { AbstractPureComponent2, Button, DISPLAYNAME_PREFIX, InputGroup, Keys, Popover, Position, refHandler, setRef } from \"@blueprintjs/core\";\nimport { Classes } from \"../../common\";\nimport { QueryList } from \"../query-list/queryList\";\n\nvar Select =\n/** @class */\nfunction (_super) {\n  __extends(Select, _super);\n\n  function Select() {\n    var _a;\n\n    var _this = _super.apply(this, arguments) || this;\n\n    _this.state = {\n      isOpen: false\n    };\n    _this.TypedQueryList = QueryList.ofType();\n    _this.inputElement = null;\n    _this.queryList = null;\n    _this.handleInputRef = refHandler(_this, \"inputElement\", (_a = _this.props.inputProps) === null || _a === void 0 ? void 0 : _a.inputRef);\n\n    _this.handleQueryListRef = function (ref) {\n      return _this.queryList = ref;\n    };\n\n    _this.renderQueryList = function (listProps) {\n      var _a; // not using defaultProps cuz they're hard to type with generics (can't use <T> on static members)\n\n\n      var _b = _this.props,\n          fill = _b.fill,\n          _c = _b.filterable,\n          filterable = _c === void 0 ? true : _c,\n          _d = _b.disabled,\n          disabled = _d === void 0 ? false : _d,\n          _e = _b.inputProps,\n          inputProps = _e === void 0 ? {} : _e,\n          _f = _b.popoverProps,\n          popoverProps = _f === void 0 ? {} : _f,\n          matchTargetWidth = _b.matchTargetWidth;\n\n      if (fill) {\n        popoverProps.fill = true;\n      }\n\n      if (matchTargetWidth) {\n        if (popoverProps.modifiers == null) {\n          popoverProps.modifiers = {};\n        }\n\n        popoverProps.modifiers.minWidth = {\n          enabled: true,\n          fn: function (data) {\n            data.styles.width = data.offsets.reference.width + \"px\";\n            return data;\n          },\n          order: 800\n        };\n        popoverProps.usePortal = false;\n        popoverProps.wrapperTagName = \"div\";\n      }\n\n      var input = React.createElement(InputGroup, __assign({\n        leftIcon: \"search\",\n        placeholder: \"Filter...\",\n        rightElement: _this.maybeRenderClearButton(listProps.query)\n      }, inputProps, {\n        inputRef: _this.handleInputRef,\n        onChange: listProps.handleQueryChange,\n        value: listProps.query\n      }));\n      var handleKeyDown = listProps.handleKeyDown,\n          handleKeyUp = listProps.handleKeyUp;\n      return (\n        /* eslint-disable-next-line deprecation/deprecation */\n        React.createElement(Popover, __assign({\n          autoFocus: false,\n          enforceFocus: false,\n          isOpen: _this.state.isOpen,\n          disabled: disabled,\n          position: Position.BOTTOM_LEFT\n        }, popoverProps, {\n          className: classNames(listProps.className, popoverProps.className),\n          onInteraction: _this.handlePopoverInteraction,\n          popoverClassName: classNames(Classes.SELECT_POPOVER, popoverProps.popoverClassName, (_a = {}, _a[Classes.SELECT_MATCH_TARGET_WIDTH] = matchTargetWidth, _a)),\n          onOpening: _this.handlePopoverOpening,\n          onOpened: _this.handlePopoverOpened,\n          onClosing: _this.handlePopoverClosing\n        }), React.createElement(\"div\", {\n          onKeyDown: _this.state.isOpen ? handleKeyDown : _this.handleTargetKeyDown,\n          onKeyUp: _this.state.isOpen ? handleKeyUp : undefined\n        }, _this.props.children), React.createElement(\"div\", {\n          onKeyDown: handleKeyDown,\n          onKeyUp: handleKeyUp\n        }, filterable ? input : undefined, listProps.itemList))\n      );\n    };\n\n    _this.handleTargetKeyDown = function (event) {\n      // open popover when arrow key pressed on target while closed\n      // HACKHACK: https://github.com/palantir/blueprint/issues/4165\n      // eslint-disable-next-line deprecation/deprecation\n      if (event.which === Keys.ARROW_UP || event.which === Keys.ARROW_DOWN) {\n        event.preventDefault();\n\n        _this.setState({\n          isOpen: true\n        });\n      }\n    };\n\n    _this.handleItemSelect = function (item, event) {\n      var _a, _b;\n\n      _this.setState({\n        isOpen: false\n      });\n\n      (_b = (_a = _this.props).onItemSelect) === null || _b === void 0 ? void 0 : _b.call(_a, item, event);\n    };\n\n    _this.handlePopoverInteraction = function (isOpen, event) {\n      var _a, _b;\n\n      _this.setState({\n        isOpen: isOpen\n      });\n\n      (_b = (_a = _this.props.popoverProps) === null || _a === void 0 ? void 0 : _a.onInteraction) === null || _b === void 0 ? void 0 : _b.call(_a, isOpen, event);\n    };\n\n    _this.handlePopoverOpening = function (node) {\n      var _a, _b; // save currently focused element before popover steals focus, so we can restore it when closing.\n\n\n      _this.previousFocusedElement = document.activeElement;\n\n      if (_this.props.resetOnClose) {\n        _this.resetQuery();\n      }\n\n      (_b = (_a = _this.props.popoverProps) === null || _a === void 0 ? void 0 : _a.onOpening) === null || _b === void 0 ? void 0 : _b.call(_a, node);\n    };\n\n    _this.handlePopoverOpened = function (node) {\n      var _a, _b; // scroll active item into view after popover transition completes and all dimensions are stable.\n\n\n      if (_this.queryList != null) {\n        _this.queryList.scrollActiveItemIntoView();\n      }\n\n      _this.requestAnimationFrame(function () {\n        var _a;\n\n        var _b = _this.props.inputProps,\n            inputProps = _b === void 0 ? {} : _b; // autofocus is enabled by default\n\n        if (inputProps.autoFocus !== false) {\n          (_a = _this.inputElement) === null || _a === void 0 ? void 0 : _a.focus();\n        }\n      });\n\n      (_b = (_a = _this.props.popoverProps) === null || _a === void 0 ? void 0 : _a.onOpened) === null || _b === void 0 ? void 0 : _b.call(_a, node);\n    };\n\n    _this.handlePopoverClosing = function (node) {\n      var _a, _b; // restore focus to saved element.\n      // timeout allows popover to begin closing and remove focus handlers beforehand.\n\n\n      _this.requestAnimationFrame(function () {\n        if (_this.previousFocusedElement !== undefined) {\n          _this.previousFocusedElement.focus();\n\n          _this.previousFocusedElement = undefined;\n        }\n      });\n\n      (_b = (_a = _this.props.popoverProps) === null || _a === void 0 ? void 0 : _a.onClosing) === null || _b === void 0 ? void 0 : _b.call(_a, node);\n    };\n\n    _this.resetQuery = function () {\n      return _this.queryList && _this.queryList.setQuery(\"\", true);\n    };\n\n    return _this;\n  }\n\n  Select.ofType = function () {\n    return Select;\n  };\n\n  Select.prototype.render = function () {\n    // omit props specific to this component, spread the rest.\n    var _a = this.props,\n        filterable = _a.filterable,\n        inputProps = _a.inputProps,\n        popoverProps = _a.popoverProps,\n        restProps = __rest(_a, [\"filterable\", \"inputProps\", \"popoverProps\"]);\n\n    return React.createElement(this.TypedQueryList, __assign({}, restProps, {\n      onItemSelect: this.handleItemSelect,\n      ref: this.handleQueryListRef,\n      renderer: this.renderQueryList\n    }));\n  };\n\n  Select.prototype.componentDidUpdate = function (prevProps, prevState) {\n    var _a, _b, _c, _d, _e;\n\n    if (((_a = prevProps.inputProps) === null || _a === void 0 ? void 0 : _a.inputRef) !== ((_b = this.props.inputProps) === null || _b === void 0 ? void 0 : _b.inputRef)) {\n      setRef((_c = prevProps.inputProps) === null || _c === void 0 ? void 0 : _c.inputRef, null);\n      this.handleInputRef = refHandler(this, \"inputElement\", (_d = this.props.inputProps) === null || _d === void 0 ? void 0 : _d.inputRef);\n      setRef((_e = this.props.inputProps) === null || _e === void 0 ? void 0 : _e.inputRef, this.inputElement);\n    }\n\n    if (this.state.isOpen && !prevState.isOpen && this.queryList != null) {\n      this.queryList.scrollActiveItemIntoView();\n    }\n  };\n\n  Select.prototype.maybeRenderClearButton = function (query) {\n    return query.length > 0 ? React.createElement(Button, {\n      icon: \"cross\",\n      minimal: true,\n      onClick: this.resetQuery\n    }) : undefined;\n  };\n\n  Select.displayName = DISPLAYNAME_PREFIX + \".Select\";\n  return Select;\n}(AbstractPureComponent2);\n\nexport { Select };","map":null,"metadata":{},"sourceType":"module"}