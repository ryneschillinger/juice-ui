{"ast":null,"code":"/* !\n * Copyright 2020 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { __assign, __decorate, __extends, __rest } from \"tslib\";\nimport * as React from \"react\";\nimport { polyfill } from \"react-lifecycles-compat\";\nimport { DISPLAYNAME_PREFIX } from \"../../common/props\";\n/**\n * A stateful wrapper around the low-level <input> component which works around a\n * [React bug](https://github.com/facebook/react/issues/3926). This bug is reproduced when an input\n * receives CompositionEvents (for example, through IME composition) and has its value prop updated\n * asychronously. This might happen if a component chooses to do async validation of a value\n * returned by the input's `onChange` callback.\n *\n * Note: this component does not apply any Blueprint-specific styling.\n */\n\nvar AsyncControllableInput =\n/** @class */\nfunction (_super) {\n  __extends(AsyncControllableInput, _super);\n\n  function AsyncControllableInput() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.state = {\n      hasPendingUpdate: false,\n      isComposing: false,\n      nextValue: _this.props.value,\n      value: _this.props.value\n    };\n\n    _this.handleCompositionStart = function (e) {\n      var _a, _b;\n\n      _this.setState({\n        isComposing: true,\n        // Make sure that localValue matches externalValue, in case externalValue\n        // has changed since the last onChange event.\n        nextValue: _this.state.value\n      });\n\n      (_b = (_a = _this.props).onCompositionStart) === null || _b === void 0 ? void 0 : _b.call(_a, e);\n    };\n\n    _this.handleCompositionEnd = function (e) {\n      var _a, _b;\n\n      _this.setState({\n        isComposing: false\n      });\n\n      (_b = (_a = _this.props).onCompositionEnd) === null || _b === void 0 ? void 0 : _b.call(_a, e);\n    };\n\n    _this.handleChange = function (e) {\n      var _a, _b;\n\n      var value = e.target.value;\n\n      _this.setState({\n        nextValue: value\n      });\n\n      (_b = (_a = _this.props).onChange) === null || _b === void 0 ? void 0 : _b.call(_a, e);\n    };\n\n    return _this;\n  }\n\n  AsyncControllableInput.getDerivedStateFromProps = function (nextProps, nextState) {\n    if (nextState.isComposing || nextProps.value === undefined) {\n      // don't derive anything from props if:\n      // - in uncontrolled mode, OR\n      // - currently composing, since we'll do that after composition ends\n      return null;\n    }\n\n    var userTriggeredUpdate = nextState.nextValue !== nextState.value;\n\n    if (userTriggeredUpdate) {\n      if (nextProps.value === nextState.nextValue) {\n        // parent has processed and accepted our update\n        if (nextState.hasPendingUpdate) {\n          return {\n            value: nextProps.value,\n            hasPendingUpdate: false\n          };\n        } else {\n          return {\n            value: nextState.nextValue\n          };\n        }\n      } else {\n        if (nextProps.value === nextState.value) {\n          // we have sent the update to our parent, but it has not been processed yet. just wait.\n          // DO NOT set nextValue here, since that will temporarily render a potentially stale controlled value,\n          // causing the cursor to jump once the new value is accepted\n          return {\n            hasPendingUpdate: true\n          };\n        } // accept controlled update overriding user action\n\n\n        return {\n          value: nextProps.value,\n          nextValue: nextProps.value,\n          hasPendingUpdate: false\n        };\n      }\n    } else {\n      // accept controlled update, could be confirming or denying user action\n      return {\n        value: nextProps.value,\n        nextValue: nextProps.value,\n        hasPendingUpdate: false\n      };\n    }\n  };\n\n  AsyncControllableInput.prototype.render = function () {\n    var _a = this.state,\n        isComposing = _a.isComposing,\n        hasPendingUpdate = _a.hasPendingUpdate,\n        value = _a.value,\n        nextValue = _a.nextValue;\n\n    var _b = this.props,\n        inputRef = _b.inputRef,\n        restProps = __rest(_b, [\"inputRef\"]);\n\n    return React.createElement(\"input\", __assign({}, restProps, {\n      ref: inputRef,\n      // render the pending value even if it is not confirmed by a parent's async controlled update\n      // so that the cursor does not jump to the end of input as reported in\n      // https://github.com/palantir/blueprint/issues/4298\n      value: isComposing || hasPendingUpdate ? nextValue : value,\n      onCompositionStart: this.handleCompositionStart,\n      onCompositionEnd: this.handleCompositionEnd,\n      onChange: this.handleChange\n    }));\n  };\n\n  AsyncControllableInput.displayName = DISPLAYNAME_PREFIX + \".AsyncControllableInput\";\n  AsyncControllableInput = __decorate([polyfill], AsyncControllableInput);\n  return AsyncControllableInput;\n}(React.PureComponent);\n\nexport { AsyncControllableInput };","map":null,"metadata":{},"sourceType":"module"}