{"ast":null,"code":"/*\n * Copyright 2017 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { __assign, __extends, __rest } from \"tslib\";\nimport classNames from \"classnames\";\nimport * as React from \"react\";\nimport { AbstractPureComponent2, DISPLAYNAME_PREFIX, InputGroup, Keys, Popover, PopoverInteractionKind, Position, refHandler, setRef } from \"@blueprintjs/core\";\nimport { Classes } from \"../../common\";\nimport { QueryList } from \"../query-list/queryList\";\n\nvar Suggest =\n/** @class */\nfunction (_super) {\n  __extends(Suggest, _super);\n\n  function Suggest() {\n    var _a;\n\n    var _this = _super.apply(this, arguments) || this;\n\n    _this.state = {\n      isOpen: _this.props.popoverProps != null && _this.props.popoverProps.isOpen || false,\n      selectedItem: _this.getInitialSelectedItem()\n    };\n    _this.TypedQueryList = QueryList.ofType();\n    _this.inputElement = null;\n    _this.queryList = null;\n    _this.handleInputRef = refHandler(_this, \"inputElement\", (_a = _this.props.inputProps) === null || _a === void 0 ? void 0 : _a.inputRef);\n\n    _this.handleQueryListRef = function (ref) {\n      return _this.queryList = ref;\n    };\n\n    _this.renderQueryList = function (listProps) {\n      var _a = _this.props,\n          fill = _a.fill,\n          _b = _a.inputProps,\n          inputProps = _b === void 0 ? {} : _b,\n          _c = _a.popoverProps,\n          popoverProps = _c === void 0 ? {} : _c;\n      var _d = _this.state,\n          isOpen = _d.isOpen,\n          selectedItem = _d.selectedItem;\n      var handleKeyDown = listProps.handleKeyDown,\n          handleKeyUp = listProps.handleKeyUp;\n      var _e = inputProps.autoComplete,\n          autoComplete = _e === void 0 ? \"off\" : _e,\n          _f = inputProps.placeholder,\n          placeholder = _f === void 0 ? \"Search...\" : _f;\n      var selectedItemText = selectedItem ? _this.props.inputValueRenderer(selectedItem) : \"\"; // placeholder shows selected item while open.\n\n      var inputPlaceholder = isOpen && selectedItemText ? selectedItemText : placeholder; // value shows query when open, and query remains when closed if nothing is selected.\n      // if resetOnClose is enabled, then hide query when not open. (see handlePopoverOpening)\n\n      var inputValue = isOpen ? listProps.query : selectedItemText || (_this.props.resetOnClose ? \"\" : listProps.query);\n\n      if (fill) {\n        popoverProps.fill = true;\n        inputProps.fill = true;\n      }\n\n      return (\n        /* eslint-disable-next-line deprecation/deprecation */\n        React.createElement(Popover, __assign({\n          autoFocus: false,\n          enforceFocus: false,\n          isOpen: isOpen,\n          position: Position.BOTTOM_LEFT\n        }, popoverProps, {\n          className: classNames(listProps.className, popoverProps.className),\n          interactionKind: PopoverInteractionKind.CLICK,\n          onInteraction: _this.handlePopoverInteraction,\n          popoverClassName: classNames(Classes.SELECT_POPOVER, popoverProps.popoverClassName),\n          onOpening: _this.handlePopoverOpening,\n          onOpened: _this.handlePopoverOpened\n        }), React.createElement(InputGroup, __assign({\n          autoComplete: autoComplete,\n          disabled: _this.props.disabled\n        }, inputProps, {\n          inputRef: _this.handleInputRef,\n          onChange: listProps.handleQueryChange,\n          onFocus: _this.handleInputFocus,\n          onKeyDown: _this.getTargetKeyDownHandler(handleKeyDown),\n          onKeyUp: _this.getTargetKeyUpHandler(handleKeyUp),\n          placeholder: inputPlaceholder,\n          value: inputValue\n        })), React.createElement(\"div\", {\n          onKeyDown: handleKeyDown,\n          onKeyUp: handleKeyUp\n        }, listProps.itemList))\n      );\n    };\n\n    _this.selectText = function () {\n      // wait until the input is properly focused to select the text inside of it\n      _this.requestAnimationFrame(function () {\n        var _a;\n\n        (_a = _this.inputElement) === null || _a === void 0 ? void 0 : _a.setSelectionRange(0, _this.inputElement.value.length);\n      });\n    };\n\n    _this.handleInputFocus = function (event) {\n      var _a, _b;\n\n      _this.selectText(); // TODO can we leverage Popover.openOnTargetFocus for this?\n\n\n      if (!_this.props.openOnKeyDown) {\n        _this.setState({\n          isOpen: true\n        });\n      }\n\n      (_b = (_a = _this.props.inputProps) === null || _a === void 0 ? void 0 : _a.onFocus) === null || _b === void 0 ? void 0 : _b.call(_a, event);\n    };\n\n    _this.handleItemSelect = function (item, event) {\n      var _a, _b, _c, _d;\n\n      var nextOpenState;\n\n      if (!_this.props.closeOnSelect) {\n        (_a = _this.inputElement) === null || _a === void 0 ? void 0 : _a.focus();\n\n        _this.selectText();\n\n        nextOpenState = true;\n      } else {\n        (_b = _this.inputElement) === null || _b === void 0 ? void 0 : _b.blur();\n        nextOpenState = false;\n      } // the internal state should only change when uncontrolled.\n\n\n      if (_this.props.selectedItem === undefined) {\n        _this.setState({\n          isOpen: nextOpenState,\n          selectedItem: item\n        });\n      } else {\n        // otherwise just set the next open state.\n        _this.setState({\n          isOpen: nextOpenState\n        });\n      }\n\n      (_d = (_c = _this.props).onItemSelect) === null || _d === void 0 ? void 0 : _d.call(_c, item, event);\n    }; // Popover interaction kind is CLICK, so this only handles click events.\n    // Note that we defer to the next animation frame in order to get the latest document.activeElement\n\n\n    _this.handlePopoverInteraction = function (nextOpenState, event) {\n      return _this.requestAnimationFrame(function () {\n        var _a, _b;\n\n        var isInputFocused = _this.inputElement === document.activeElement;\n\n        if (_this.inputElement != null && !isInputFocused) {\n          // the input is no longer focused, we should close the popover\n          _this.setState({\n            isOpen: false\n          });\n        }\n\n        (_b = (_a = _this.props.popoverProps) === null || _a === void 0 ? void 0 : _a.onInteraction) === null || _b === void 0 ? void 0 : _b.call(_a, nextOpenState, event);\n      });\n    };\n\n    _this.handlePopoverOpening = function (node) {\n      var _a, _b; // reset query before opening instead of when closing to prevent flash of unfiltered items.\n      // this is a limitation of the interactions between QueryList state and Popover transitions.\n\n\n      if (_this.props.resetOnClose && _this.queryList) {\n        _this.queryList.setQuery(\"\", true);\n      }\n\n      (_b = (_a = _this.props.popoverProps) === null || _a === void 0 ? void 0 : _a.onOpening) === null || _b === void 0 ? void 0 : _b.call(_a, node);\n    };\n\n    _this.handlePopoverOpened = function (node) {\n      var _a, _b; // scroll active item into view after popover transition completes and all dimensions are stable.\n\n\n      if (_this.queryList != null) {\n        _this.queryList.scrollActiveItemIntoView();\n      }\n\n      (_b = (_a = _this.props.popoverProps) === null || _a === void 0 ? void 0 : _a.onOpened) === null || _b === void 0 ? void 0 : _b.call(_a, node);\n    };\n\n    _this.getTargetKeyDownHandler = function (handleQueryListKeyDown) {\n      return function (evt) {\n        var _a, _b, _c; // HACKHACK: https://github.com/palantir/blueprint/issues/4165\n        // eslint-disable-next-line deprecation/deprecation\n\n\n        var which = evt.which;\n\n        if (which === Keys.ESCAPE || which === Keys.TAB) {\n          (_a = _this.inputElement) === null || _a === void 0 ? void 0 : _a.blur();\n\n          _this.setState({\n            isOpen: false\n          });\n        } else if (_this.props.openOnKeyDown && which !== Keys.BACKSPACE && which !== Keys.ARROW_LEFT && which !== Keys.ARROW_RIGHT) {\n          _this.setState({\n            isOpen: true\n          });\n        }\n\n        if (_this.state.isOpen) {\n          handleQueryListKeyDown === null || handleQueryListKeyDown === void 0 ? void 0 : handleQueryListKeyDown(evt);\n        }\n\n        (_c = (_b = _this.props.inputProps) === null || _b === void 0 ? void 0 : _b.onKeyDown) === null || _c === void 0 ? void 0 : _c.call(_b, evt);\n      };\n    };\n\n    _this.getTargetKeyUpHandler = function (handleQueryListKeyUp) {\n      return function (evt) {\n        var _a, _b;\n\n        if (_this.state.isOpen) {\n          handleQueryListKeyUp === null || handleQueryListKeyUp === void 0 ? void 0 : handleQueryListKeyUp(evt);\n        }\n\n        (_b = (_a = _this.props.inputProps) === null || _a === void 0 ? void 0 : _a.onKeyUp) === null || _b === void 0 ? void 0 : _b.call(_a, evt);\n      };\n    };\n\n    return _this;\n  }\n\n  Suggest.ofType = function () {\n    return Suggest;\n  };\n\n  Suggest.prototype.render = function () {\n    var _a; // omit props specific to this component, spread the rest.\n\n\n    var _b = this.props,\n        disabled = _b.disabled,\n        inputProps = _b.inputProps,\n        popoverProps = _b.popoverProps,\n        restProps = __rest(_b, [\"disabled\", \"inputProps\", \"popoverProps\"]);\n\n    return React.createElement(this.TypedQueryList, __assign({}, restProps, {\n      initialActiveItem: (_a = this.props.selectedItem) !== null && _a !== void 0 ? _a : undefined,\n      onItemSelect: this.handleItemSelect,\n      ref: this.handleQueryListRef,\n      renderer: this.renderQueryList\n    }));\n  };\n\n  Suggest.prototype.componentDidUpdate = function (prevProps, prevState) {\n    var _this = this;\n\n    var _a, _b, _c, _d, _e, _f, _g;\n\n    if (((_a = prevProps.inputProps) === null || _a === void 0 ? void 0 : _a.inputRef) !== ((_b = this.props.inputProps) === null || _b === void 0 ? void 0 : _b.inputRef)) {\n      setRef((_c = prevProps.inputProps) === null || _c === void 0 ? void 0 : _c.inputRef, null);\n      this.handleInputRef = refHandler(this, \"inputElement\", (_d = this.props.inputProps) === null || _d === void 0 ? void 0 : _d.inputRef);\n      setRef((_e = this.props.inputProps) === null || _e === void 0 ? void 0 : _e.inputRef, this.inputElement);\n    } // If the selected item prop changes, update the underlying state.\n\n\n    if (this.props.selectedItem !== undefined && this.props.selectedItem !== this.state.selectedItem) {\n      this.setState({\n        selectedItem: this.props.selectedItem\n      });\n    }\n\n    if (this.state.isOpen === false && prevState.isOpen === true) {\n      // just closed, likely by keyboard interaction\n      // wait until the transition ends so there isn't a flash of content in the popover\n\n      /* eslint-disable-next-line deprecation/deprecation */\n      var timeout = (_g = (_f = this.props.popoverProps) === null || _f === void 0 ? void 0 : _f.transitionDuration) !== null && _g !== void 0 ? _g : Popover.defaultProps.transitionDuration;\n      setTimeout(function () {\n        return _this.maybeResetActiveItemToSelectedItem();\n      }, timeout);\n    }\n\n    if (this.state.isOpen && !prevState.isOpen && this.queryList != null) {\n      this.queryList.scrollActiveItemIntoView();\n    }\n  };\n\n  Suggest.prototype.getInitialSelectedItem = function () {\n    // controlled > uncontrolled > default\n    if (this.props.selectedItem !== undefined) {\n      return this.props.selectedItem;\n    } else if (this.props.defaultSelectedItem !== undefined) {\n      return this.props.defaultSelectedItem;\n    } else {\n      return null;\n    }\n  };\n\n  Suggest.prototype.maybeResetActiveItemToSelectedItem = function () {\n    var _a;\n\n    var shouldResetActiveItemToSelectedItem = this.props.activeItem === undefined && this.state.selectedItem !== null && !this.props.resetOnSelect;\n\n    if (this.queryList !== null && shouldResetActiveItemToSelectedItem) {\n      this.queryList.setActiveItem((_a = this.props.selectedItem) !== null && _a !== void 0 ? _a : this.state.selectedItem);\n    }\n  };\n\n  Suggest.displayName = DISPLAYNAME_PREFIX + \".Suggest\";\n  Suggest.defaultProps = {\n    closeOnSelect: true,\n    fill: false,\n    openOnKeyDown: false,\n    resetOnClose: false\n  };\n  return Suggest;\n}(AbstractPureComponent2);\n\nexport { Suggest };","map":null,"metadata":{},"sourceType":"module"}