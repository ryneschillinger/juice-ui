{"ast":null,"code":"/*\n * Copyright 2017 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { __assign, __decorate, __extends } from \"tslib\";\nimport classNames from \"classnames\";\nimport * as React from \"react\";\nimport DayPicker from \"react-day-picker\";\nimport { polyfill } from \"react-lifecycles-compat\";\nimport { AbstractPureComponent2, Boundary, Classes, DISPLAYNAME_PREFIX, getRef, InputGroup, Intent, isRefObject, Keys, Popover, Position } from \"@blueprintjs/core\";\nimport { areSameTime, isDateValid, isDayInRange } from \"./common/dateUtils\";\nimport * as Errors from \"./common/errors\";\nimport { getFormattedDateString } from \"./dateFormat\";\nimport { getDefaultMaxDate, getDefaultMinDate } from \"./datePickerCore\";\nimport { DateRangePicker } from \"./dateRangePicker\";\n\nvar DateRangeInput =\n/** @class */\nfunction (_super) {\n  __extends(DateRangeInput, _super);\n\n  function DateRangeInput(props, context) {\n    var _this = _super.call(this, props, context) || this;\n\n    _this.startInputRef = null;\n    _this.endInputRef = null;\n    _this.refHandlers = {\n      endInputRef: isRefObject(_this.props.endInputProps.inputRef) ? _this.endInputRef = _this.props.endInputProps.inputRef : function (ref) {\n        var _a;\n\n        _this.endInputRef = ref;\n        (_a = _this.props.endInputProps.inputRef) === null || _a === void 0 ? void 0 : _a(ref);\n      },\n      startInputRef: isRefObject(_this.props.startInputProps.inputRef) ? _this.startInputRef = _this.props.startInputProps.inputRef : function (ref) {\n        var _a;\n\n        _this.startInputRef = ref;\n        (_a = _this.props.startInputProps.inputRef) === null || _a === void 0 ? void 0 : _a(ref);\n      }\n    };\n\n    _this.renderInputGroup = function (boundary) {\n      var inputProps = _this.getInputProps(boundary);\n\n      var handleInputEvent = boundary === Boundary.START ? _this.handleStartInputEvent : _this.handleEndInputEvent;\n      return React.createElement(InputGroup, __assign({\n        autoComplete: \"off\",\n        disabled: inputProps.disabled || _this.props.disabled\n      }, inputProps, {\n        intent: _this.isInputInErrorState(boundary) ? Intent.DANGER : inputProps.intent,\n        inputRef: _this.getInputRef(boundary),\n        onBlur: handleInputEvent,\n        onChange: handleInputEvent,\n        onClick: handleInputEvent,\n        onFocus: handleInputEvent,\n        onKeyDown: handleInputEvent,\n        onMouseDown: handleInputEvent,\n        placeholder: _this.getInputPlaceholderString(boundary),\n        value: _this.getInputDisplayString(boundary)\n      }));\n    }; // Callbacks - DateRangePicker\n    // ===========================\n\n\n    _this.handleDateRangePickerChange = function (selectedRange, didSubmitWithEnter) {\n      var _a, _b;\n\n      if (didSubmitWithEnter === void 0) {\n        didSubmitWithEnter = false;\n      } // ignore mouse events in the date-range picker if the popover is animating closed.\n\n\n      if (!_this.state.isOpen) {\n        return;\n      }\n\n      var selectedStart = selectedRange[0],\n          selectedEnd = selectedRange[1];\n      var isOpen = true;\n      var isStartInputFocused;\n      var isEndInputFocused;\n      var startHoverString;\n      var endHoverString;\n      var boundaryToModify;\n\n      if (selectedStart == null) {\n        // focus the start field by default or if only an end date is specified\n        if (_this.props.timePrecision == null) {\n          isStartInputFocused = true;\n          isEndInputFocused = false;\n        } else {\n          isStartInputFocused = false;\n          isEndInputFocused = false;\n          boundaryToModify = Boundary.START;\n        } // for clarity, hide the hover string until the mouse moves over a different date\n\n\n        startHoverString = null;\n      } else if (selectedEnd == null) {\n        // focus the end field if a start date is specified\n        if (_this.props.timePrecision == null) {\n          isStartInputFocused = false;\n          isEndInputFocused = true;\n        } else {\n          isStartInputFocused = false;\n          isEndInputFocused = false;\n          boundaryToModify = Boundary.END;\n        }\n\n        endHoverString = null;\n      } else if (_this.props.closeOnSelection) {\n        isOpen = _this.getIsOpenValueWhenDateChanges(selectedStart, selectedEnd);\n        isStartInputFocused = false;\n\n        if (_this.props.timePrecision == null && didSubmitWithEnter) {\n          // if we submit via click or Tab, the focus will have moved already.\n          // it we submit with Enter, the focus won't have moved, and setting\n          // the flag to false won't have an effect anyway, so leave it true.\n          isEndInputFocused = true;\n        } else {\n          isEndInputFocused = false;\n          boundaryToModify = Boundary.END;\n        }\n      } else if (_this.state.lastFocusedField === Boundary.START) {\n        // keep the start field focused\n        if (_this.props.timePrecision == null) {\n          isStartInputFocused = true;\n          isEndInputFocused = false;\n        } else {\n          isStartInputFocused = false;\n          isEndInputFocused = false;\n          boundaryToModify = Boundary.START;\n        }\n      } else if (_this.props.timePrecision == null) {\n        // keep the end field focused\n        isStartInputFocused = false;\n        isEndInputFocused = true;\n      } else {\n        isStartInputFocused = false;\n        isEndInputFocused = false;\n        boundaryToModify = Boundary.END;\n      }\n\n      var baseStateChange = {\n        boundaryToModify: boundaryToModify,\n        endHoverString: endHoverString,\n        endInputString: _this.formatDate(selectedEnd),\n        isEndInputFocused: isEndInputFocused,\n        isOpen: isOpen,\n        isStartInputFocused: isStartInputFocused,\n        startHoverString: startHoverString,\n        startInputString: _this.formatDate(selectedStart),\n        wasLastFocusChangeDueToHover: false\n      };\n\n      if (_this.isControlled()) {\n        _this.setState(baseStateChange);\n      } else {\n        _this.setState(__assign(__assign({}, baseStateChange), {\n          selectedEnd: selectedEnd,\n          selectedStart: selectedStart\n        }));\n      }\n\n      (_b = (_a = _this.props).onChange) === null || _b === void 0 ? void 0 : _b.call(_a, selectedRange);\n    };\n\n    _this.handleShortcutChange = function (_, selectedShortcutIndex) {\n      _this.setState({\n        selectedShortcutIndex: selectedShortcutIndex\n      });\n    };\n\n    _this.handleDateRangePickerHoverChange = function (hoveredRange, _hoveredDay, hoveredBoundary) {\n      // ignore mouse events in the date-range picker if the popover is animating closed.\n      if (!_this.state.isOpen) {\n        return;\n      }\n\n      if (hoveredRange == null) {\n        // undo whatever focus changes we made while hovering over various calendar dates\n        var isEndInputFocused = _this.state.boundaryToModify === Boundary.END;\n\n        _this.setState({\n          endHoverString: null,\n          isEndInputFocused: isEndInputFocused,\n          isStartInputFocused: !isEndInputFocused,\n          lastFocusedField: _this.state.boundaryToModify,\n          startHoverString: null\n        });\n      } else {\n        var hoveredStart = hoveredRange[0],\n            hoveredEnd = hoveredRange[1];\n        var isStartInputFocused = hoveredBoundary != null ? hoveredBoundary === Boundary.START : _this.state.isStartInputFocused;\n        var isEndInputFocused = hoveredBoundary != null ? hoveredBoundary === Boundary.END : _this.state.isEndInputFocused;\n\n        _this.setState({\n          endHoverString: _this.formatDate(hoveredEnd),\n          isEndInputFocused: isEndInputFocused,\n          isStartInputFocused: isStartInputFocused,\n          lastFocusedField: isStartInputFocused ? Boundary.START : Boundary.END,\n          shouldSelectAfterUpdate: _this.props.selectAllOnFocus,\n          startHoverString: _this.formatDate(hoveredStart),\n          wasLastFocusChangeDueToHover: true\n        });\n      }\n    }; // Callbacks - Input\n    // =================\n    // instantiate these two functions once so we don't have to for each callback on each render.\n\n\n    _this.handleStartInputEvent = function (e) {\n      _this.handleInputEvent(e, Boundary.START);\n    };\n\n    _this.handleEndInputEvent = function (e) {\n      _this.handleInputEvent(e, Boundary.END);\n    };\n\n    _this.handleInputEvent = function (e, boundary) {\n      var _a, _b, _c, _d, _f, _g;\n\n      var inputProps = _this.getInputProps(boundary);\n\n      switch (e.type) {\n        case \"blur\":\n          _this.handleInputBlur(e, boundary);\n\n          (_a = inputProps.onBlur) === null || _a === void 0 ? void 0 : _a.call(inputProps, e);\n          break;\n\n        case \"change\":\n          _this.handleInputChange(e, boundary);\n\n          (_b = inputProps.onChange) === null || _b === void 0 ? void 0 : _b.call(inputProps, e);\n          break;\n\n        case \"click\":\n          e = e;\n\n          _this.handleInputClick(e);\n\n          (_c = inputProps.onClick) === null || _c === void 0 ? void 0 : _c.call(inputProps, e);\n          break;\n\n        case \"focus\":\n          _this.handleInputFocus(e, boundary);\n\n          (_d = inputProps.onFocus) === null || _d === void 0 ? void 0 : _d.call(inputProps, e);\n          break;\n\n        case \"keydown\":\n          e = e;\n\n          _this.handleInputKeyDown(e);\n\n          (_f = inputProps.onKeyDown) === null || _f === void 0 ? void 0 : _f.call(inputProps, e);\n          break;\n\n        case \"mousedown\":\n          e = e;\n\n          _this.handleInputMouseDown();\n\n          (_g = inputProps.onMouseDown) === null || _g === void 0 ? void 0 : _g.call(inputProps, e);\n          break;\n\n        default:\n          break;\n      }\n    }; // add a keydown listener to persistently change focus when tabbing:\n    // - if focused in start field, Tab moves focus to end field\n    // - if focused in end field, Shift+Tab moves focus to start field\n\n\n    _this.handleInputKeyDown = function (e) {\n      // HACKHACK: https://github.com/palantir/blueprint/issues/4165\n\n      /* eslint-disable deprecation/deprecation */\n      var isTabPressed = e.which === Keys.TAB;\n      var isEnterPressed = e.which === Keys.ENTER;\n      var isShiftPressed = e.shiftKey;\n      var _a = _this.state,\n          selectedStart = _a.selectedStart,\n          selectedEnd = _a.selectedEnd; // order of JS events is our enemy here. when tabbing between fields,\n      // this handler will fire in the middle of a focus exchange when no\n      // field is currently focused. we work around this by referring to the\n      // most recently focused field, rather than the currently focused field.\n\n      var wasStartFieldFocused = _this.state.lastFocusedField === Boundary.START;\n      var wasEndFieldFocused = _this.state.lastFocusedField === Boundary.END; // move focus to the other field\n\n      if (isTabPressed) {\n        var isEndInputFocused = void 0;\n        var isStartInputFocused = void 0;\n        var isOpen = true;\n\n        if (wasStartFieldFocused && !isShiftPressed) {\n          isStartInputFocused = false;\n          isEndInputFocused = true; // prevent the default focus-change behavior to avoid race conditions;\n          // we'll handle the focus change ourselves in componentDidUpdate.\n\n          e.preventDefault();\n        } else if (wasEndFieldFocused && isShiftPressed) {\n          isStartInputFocused = true;\n          isEndInputFocused = false;\n          e.preventDefault();\n        } else {\n          // don't prevent default here, otherwise Tab won't do anything.\n          isStartInputFocused = false;\n          isEndInputFocused = false;\n          isOpen = false;\n        }\n\n        _this.setState({\n          isEndInputFocused: isEndInputFocused,\n          isOpen: isOpen,\n          isStartInputFocused: isStartInputFocused,\n          wasLastFocusChangeDueToHover: false\n        });\n      } else if (wasStartFieldFocused && isEnterPressed) {\n        var nextStartDate = _this.parseDate(_this.state.startInputString);\n\n        _this.handleDateRangePickerChange([nextStartDate, selectedEnd], true);\n      } else if (wasEndFieldFocused && isEnterPressed) {\n        var nextEndDate = _this.parseDate(_this.state.endInputString);\n\n        _this.handleDateRangePickerChange([selectedStart, nextEndDate], true);\n      } else {\n        // let the default keystroke happen without side effects\n        return;\n      }\n    };\n\n    _this.handleInputMouseDown = function () {\n      // clicking in the field constitutes an explicit focus change. we update\n      // the flag on \"mousedown\" instead of on \"click\", because it needs to be\n      // set before onFocus is called (\"click\" triggers after \"focus\").\n      _this.setState({\n        wasLastFocusChangeDueToHover: false\n      });\n    };\n\n    _this.handleInputClick = function (e) {\n      // unless we stop propagation on this event, a click within an input\n      // will close the popover almost as soon as it opens.\n      e.stopPropagation();\n    };\n\n    _this.handleInputFocus = function (_e, boundary) {\n      var _a;\n\n      var _b = _this.getStateKeysAndValuesForBoundary(boundary),\n          keys = _b.keys,\n          values = _b.values;\n\n      var inputString = getFormattedDateString(values.selectedValue, _this.props, true); // change the boundary only if the user explicitly focused in the field.\n      // focus changes from hovering don't count; they're just temporary.\n\n      var boundaryToModify = _this.state.wasLastFocusChangeDueToHover ? _this.state.boundaryToModify : boundary;\n\n      _this.setState((_a = {}, _a[keys.inputString] = inputString, _a[keys.isInputFocused] = true, _a.boundaryToModify = boundaryToModify, _a.isOpen = true, _a.lastFocusedField = boundary, _a.shouldSelectAfterUpdate = _this.props.selectAllOnFocus, _a.wasLastFocusChangeDueToHover = false, _a));\n    };\n\n    _this.handleInputBlur = function (_e, boundary) {\n      var _a, _b, _c, _d;\n\n      var _f, _g;\n\n      var _h = _this.getStateKeysAndValuesForBoundary(boundary),\n          keys = _h.keys,\n          values = _h.values;\n\n      var maybeNextDate = _this.parseDate(values.inputString);\n\n      var isValueControlled = _this.isControlled();\n\n      var nextState = (_a = {}, _a[keys.isInputFocused] = false, _a.shouldSelectAfterUpdate = false, _a);\n\n      if (_this.isInputEmpty(values.inputString)) {\n        if (isValueControlled) {\n          nextState = __assign(__assign({}, nextState), (_b = {}, _b[keys.inputString] = getFormattedDateString(values.controlledValue, _this.props), _b));\n        } else {\n          nextState = __assign(__assign({}, nextState), (_c = {}, _c[keys.inputString] = null, _c[keys.selectedValue] = null, _c));\n        }\n      } else if (!_this.isNextDateRangeValid(maybeNextDate, boundary)) {\n        if (!isValueControlled) {\n          nextState = __assign(__assign({}, nextState), (_d = {}, _d[keys.inputString] = null, _d[keys.selectedValue] = maybeNextDate, _d));\n        }\n\n        (_g = (_f = _this.props).onError) === null || _g === void 0 ? void 0 : _g.call(_f, _this.getDateRangeForCallback(maybeNextDate, boundary));\n      }\n\n      _this.setState(nextState);\n    };\n\n    _this.handleInputChange = function (e, boundary) {\n      var _a, _b, _c, _d, _f;\n\n      var _g, _h, _j, _k;\n\n      var inputString = e.target.value;\n\n      var keys = _this.getStateKeysAndValuesForBoundary(boundary).keys;\n\n      var maybeNextDate = _this.parseDate(inputString);\n\n      var isValueControlled = _this.isControlled();\n\n      var nextState = {\n        shouldSelectAfterUpdate: false\n      };\n\n      if (inputString.length === 0) {\n        // this case will be relevant when we start showing the hovered range in the input\n        // fields. goal is to show an empty field for clarity until the mouse moves over a\n        // different date.\n        var baseState = __assign(__assign({}, nextState), (_a = {}, _a[keys.inputString] = \"\", _a));\n\n        if (isValueControlled) {\n          nextState = baseState;\n        } else {\n          nextState = __assign(__assign({}, baseState), (_b = {}, _b[keys.selectedValue] = null, _b));\n        }\n\n        (_h = (_g = _this.props).onChange) === null || _h === void 0 ? void 0 : _h.call(_g, _this.getDateRangeForCallback(null, boundary));\n      } else if (_this.isDateValidAndInRange(maybeNextDate)) {\n        // note that error cases that depend on both fields (e.g. overlapping dates) should fall\n        // through into this block so that the UI can update immediately, possibly with an error\n        // message on the other field.\n        // also, clear the hover string to ensure the most recent keystroke appears.\n        var baseState = __assign(__assign({}, nextState), (_c = {}, _c[keys.hoverString] = null, _c[keys.inputString] = inputString, _c));\n\n        if (isValueControlled) {\n          nextState = baseState;\n        } else {\n          nextState = __assign(__assign({}, baseState), (_d = {}, _d[keys.selectedValue] = maybeNextDate, _d));\n        }\n\n        if (_this.isNextDateRangeValid(maybeNextDate, boundary)) {\n          (_k = (_j = _this.props).onChange) === null || _k === void 0 ? void 0 : _k.call(_j, _this.getDateRangeForCallback(maybeNextDate, boundary));\n        }\n      } else {\n        // again, clear the hover string to ensure the most recent keystroke appears\n        nextState = __assign(__assign({}, nextState), (_f = {}, _f[keys.inputString] = inputString, _f[keys.hoverString] = null, _f));\n      }\n\n      _this.setState(nextState);\n    }; // Callbacks - Popover\n    // ===================\n\n\n    _this.handlePopoverClose = function (event) {\n      var _a, _b;\n\n      _this.setState({\n        isOpen: false\n      });\n\n      (_b = (_a = _this.props.popoverProps).onClose) === null || _b === void 0 ? void 0 : _b.call(_a, event);\n    };\n\n    _this.getIsOpenValueWhenDateChanges = function (nextSelectedStart, nextSelectedEnd) {\n      if (_this.props.closeOnSelection) {\n        // trivial case when TimePicker is not shown\n        if (_this.props.timePrecision == null) {\n          return false;\n        }\n\n        var fallbackDate = new Date(new Date().setHours(0, 0, 0, 0));\n\n        var _a = _this.getSelectedRange([fallbackDate, fallbackDate]),\n            selectedStart = _a[0],\n            selectedEnd = _a[1]; // case to check if the user has changed TimePicker values\n\n\n        if (areSameTime(selectedStart, nextSelectedStart) === true && areSameTime(selectedEnd, nextSelectedEnd) === true) {\n          return false;\n        }\n\n        return true;\n      }\n\n      return true;\n    };\n\n    _this.getInitialRange = function (props) {\n      if (props === void 0) {\n        props = _this.props;\n      }\n\n      var defaultValue = props.defaultValue,\n          value = props.value;\n\n      if (value != null) {\n        return value;\n      } else if (defaultValue != null) {\n        return defaultValue;\n      } else {\n        return [null, null];\n      }\n    };\n\n    _this.getSelectedRange = function (fallbackRange) {\n      var _a;\n\n      var selectedStart;\n      var selectedEnd;\n\n      if (_this.isControlled()) {\n        _a = _this.props.value, selectedStart = _a[0], selectedEnd = _a[1];\n      } else {\n        selectedStart = _this.state.selectedStart;\n        selectedEnd = _this.state.selectedEnd;\n      } // this helper function checks if the provided boundary date *would* overlap the selected\n      // other boundary date. providing the already-selected start date simply tells us if we're\n      // currently in an overlapping state.\n\n\n      var doBoundaryDatesOverlap = _this.doBoundaryDatesOverlap(selectedStart, Boundary.START);\n\n      var dateRange = [selectedStart, doBoundaryDatesOverlap ? undefined : selectedEnd];\n      return dateRange.map(function (selectedBound, index) {\n        var fallbackDate = fallbackRange != null ? fallbackRange[index] : undefined;\n        return _this.isDateValidAndInRange(selectedBound) ? selectedBound : fallbackDate;\n      });\n    };\n\n    _this.getInputDisplayString = function (boundary) {\n      var values = _this.getStateKeysAndValuesForBoundary(boundary).values;\n\n      var isInputFocused = values.isInputFocused,\n          inputString = values.inputString,\n          selectedValue = values.selectedValue,\n          hoverString = values.hoverString;\n\n      if (hoverString != null) {\n        return hoverString;\n      } else if (isInputFocused) {\n        return inputString == null ? \"\" : inputString;\n      } else if (selectedValue == null) {\n        return \"\";\n      } else if (_this.doesEndBoundaryOverlapStartBoundary(selectedValue, boundary)) {\n        return _this.props.overlappingDatesMessage;\n      } else {\n        return getFormattedDateString(selectedValue, _this.props);\n      }\n    };\n\n    _this.getInputPlaceholderString = function (boundary) {\n      var isStartBoundary = boundary === Boundary.START;\n      var isEndBoundary = boundary === Boundary.END;\n\n      var inputProps = _this.getInputProps(boundary);\n\n      var isInputFocused = _this.getStateKeysAndValuesForBoundary(boundary).values.isInputFocused; // use the custom placeholder text for the input, if providied\n\n\n      if (inputProps.placeholder != null) {\n        return inputProps.placeholder;\n      } else if (isStartBoundary) {\n        return isInputFocused ? _this.state.formattedMinDateString : \"Start date\";\n      } else if (isEndBoundary) {\n        return isInputFocused ? _this.state.formattedMaxDateString : \"End date\";\n      } else {\n        return \"\";\n      }\n    };\n\n    _this.getInputProps = function (boundary) {\n      return boundary === Boundary.START ? _this.props.startInputProps : _this.props.endInputProps;\n    };\n\n    _this.getInputRef = function (boundary) {\n      return boundary === Boundary.START ? _this.refHandlers.startInputRef : _this.refHandlers.endInputRef;\n    };\n\n    _this.getStateKeysAndValuesForBoundary = function (boundary) {\n      var controlledRange = _this.props.value;\n\n      if (boundary === Boundary.START) {\n        return {\n          keys: {\n            hoverString: \"startHoverString\",\n            inputString: \"startInputString\",\n            isInputFocused: \"isStartInputFocused\",\n            selectedValue: \"selectedStart\"\n          },\n          values: {\n            controlledValue: controlledRange != null ? controlledRange[0] : undefined,\n            hoverString: _this.state.startHoverString,\n            inputString: _this.state.startInputString,\n            isInputFocused: _this.state.isStartInputFocused,\n            selectedValue: _this.state.selectedStart\n          }\n        };\n      } else {\n        return {\n          keys: {\n            hoverString: \"endHoverString\",\n            inputString: \"endInputString\",\n            isInputFocused: \"isEndInputFocused\",\n            selectedValue: \"selectedEnd\"\n          },\n          values: {\n            controlledValue: controlledRange != null ? controlledRange[1] : undefined,\n            hoverString: _this.state.endHoverString,\n            inputString: _this.state.endInputString,\n            isInputFocused: _this.state.isEndInputFocused,\n            selectedValue: _this.state.selectedEnd\n          }\n        };\n      }\n    };\n\n    _this.getDateRangeForCallback = function (currDate, currBoundary) {\n      var otherBoundary = _this.getOtherBoundary(currBoundary);\n\n      var otherDate = _this.getStateKeysAndValuesForBoundary(otherBoundary).values.selectedValue;\n\n      return currBoundary === Boundary.START ? [currDate, otherDate] : [otherDate, currDate];\n    };\n\n    _this.getOtherBoundary = function (boundary) {\n      return boundary === Boundary.START ? Boundary.END : Boundary.START;\n    };\n\n    _this.doBoundaryDatesOverlap = function (date, boundary) {\n      var allowSingleDayRange = _this.props.allowSingleDayRange;\n\n      var otherBoundary = _this.getOtherBoundary(boundary);\n\n      var otherBoundaryDate = _this.getStateKeysAndValuesForBoundary(otherBoundary).values.selectedValue;\n\n      if (date == null || otherBoundaryDate == null) {\n        return false;\n      }\n\n      if (boundary === Boundary.START) {\n        var isAfter = date > otherBoundaryDate;\n        return isAfter || !allowSingleDayRange && DayPicker.DateUtils.isSameDay(date, otherBoundaryDate);\n      } else {\n        var isBefore = date < otherBoundaryDate;\n        return isBefore || !allowSingleDayRange && DayPicker.DateUtils.isSameDay(date, otherBoundaryDate);\n      }\n    };\n    /**\n     * Returns true if the provided boundary is an END boundary overlapping the\n     * selected start date. (If the boundaries overlap, we consider the END\n     * boundary to be erroneous.)\n     */\n\n\n    _this.doesEndBoundaryOverlapStartBoundary = function (boundaryDate, boundary) {\n      return boundary === Boundary.START ? false : _this.doBoundaryDatesOverlap(boundaryDate, boundary);\n    };\n\n    _this.isControlled = function () {\n      return _this.props.value !== undefined;\n    };\n\n    _this.isInputEmpty = function (inputString) {\n      return inputString == null || inputString.length === 0;\n    };\n\n    _this.isInputInErrorState = function (boundary) {\n      var values = _this.getStateKeysAndValuesForBoundary(boundary).values;\n\n      var isInputFocused = values.isInputFocused,\n          hoverString = values.hoverString,\n          inputString = values.inputString,\n          selectedValue = values.selectedValue;\n\n      if (hoverString != null || _this.isInputEmpty(inputString)) {\n        // don't show an error state while we're hovering over a valid date.\n        return false;\n      }\n\n      var boundaryValue = isInputFocused ? _this.parseDate(inputString) : selectedValue;\n      return boundaryValue != null && (!_this.isDateValidAndInRange(boundaryValue) || _this.doesEndBoundaryOverlapStartBoundary(boundaryValue, boundary));\n    };\n\n    _this.isDateValidAndInRange = function (date) {\n      return isDateValid(date) && isDayInRange(date, [_this.props.minDate, _this.props.maxDate]);\n    };\n\n    _this.reset(props);\n\n    return _this;\n  }\n\n  DateRangeInput_1 = DateRangeInput;\n  /**\n   * Public method intended for unit testing only. Do not use in feature work!\n   */\n\n  DateRangeInput.prototype.reset = function (props) {\n    if (props === void 0) {\n      props = this.props;\n    }\n\n    var _a = this.getInitialRange(),\n        selectedStart = _a[0],\n        selectedEnd = _a[1];\n\n    this.state = {\n      formattedMaxDateString: this.getFormattedMinMaxDateString(props, \"maxDate\"),\n      formattedMinDateString: this.getFormattedMinMaxDateString(props, \"minDate\"),\n      isOpen: false,\n      selectedEnd: selectedEnd,\n      selectedShortcutIndex: -1,\n      selectedStart: selectedStart\n    };\n  };\n\n  DateRangeInput.prototype.componentDidUpdate = function (prevProps, prevState) {\n    _super.prototype.componentDidUpdate.call(this, prevProps, prevState);\n\n    var _a = this.state,\n        isStartInputFocused = _a.isStartInputFocused,\n        isEndInputFocused = _a.isEndInputFocused,\n        shouldSelectAfterUpdate = _a.shouldSelectAfterUpdate;\n    var startInputRef = getRef(this.startInputRef);\n    var endInputRef = getRef(this.endInputRef);\n    var shouldFocusStartInput = this.shouldFocusInputRef(isStartInputFocused, startInputRef);\n    var shouldFocusEndInput = this.shouldFocusInputRef(isEndInputFocused, endInputRef);\n\n    if (shouldFocusStartInput) {\n      startInputRef.focus();\n    } else if (shouldFocusEndInput) {\n      endInputRef.focus();\n    }\n\n    if (isStartInputFocused && shouldSelectAfterUpdate) {\n      startInputRef.select();\n    } else if (isEndInputFocused && shouldSelectAfterUpdate) {\n      endInputRef.select();\n    }\n\n    var nextState = {};\n\n    if (this.props.value !== prevProps.value) {\n      var _b = this.getInitialRange(this.props),\n          selectedStart = _b[0],\n          selectedEnd = _b[1];\n\n      nextState = __assign(__assign({}, nextState), {\n        selectedStart: selectedStart,\n        selectedEnd: selectedEnd\n      });\n    } // cache the formatted date strings to avoid computing on each render.\n\n\n    if (this.props.minDate !== prevProps.minDate) {\n      var formattedMinDateString = this.getFormattedMinMaxDateString(this.props, \"minDate\");\n      nextState = __assign(__assign({}, nextState), {\n        formattedMinDateString: formattedMinDateString\n      });\n    }\n\n    if (this.props.maxDate !== prevProps.maxDate) {\n      var formattedMaxDateString = this.getFormattedMinMaxDateString(this.props, \"maxDate\");\n      nextState = __assign(__assign({}, nextState), {\n        formattedMaxDateString: formattedMaxDateString\n      });\n    }\n\n    this.setState(nextState);\n  };\n\n  DateRangeInput.prototype.render = function () {\n    var selectedShortcutIndex = this.state.selectedShortcutIndex;\n    var _a = this.props.popoverProps,\n        popoverProps = _a === void 0 ? {} : _a;\n    var popoverContent = React.createElement(DateRangePicker, __assign({}, this.props, {\n      selectedShortcutIndex: selectedShortcutIndex,\n      boundaryToModify: this.state.boundaryToModify,\n      onChange: this.handleDateRangePickerChange,\n      onShortcutChange: this.handleShortcutChange,\n      onHoverChange: this.handleDateRangePickerHoverChange,\n      value: this.getSelectedRange()\n    }));\n    var popoverClassName = classNames(popoverProps.className, this.props.className); // allow custom props for the popover and each input group, but pass them in an order that\n    // guarantees only some props are overridable.\n\n    return React.createElement(Popover, __assign({\n      isOpen: this.state.isOpen,\n      position: Position.BOTTOM_LEFT\n    }, this.props.popoverProps, {\n      autoFocus: false,\n      className: popoverClassName,\n      content: popoverContent,\n      enforceFocus: false,\n      onClose: this.handlePopoverClose\n    }), React.createElement(\"div\", {\n      className: Classes.CONTROL_GROUP\n    }, this.renderInputGroup(Boundary.START), this.renderInputGroup(Boundary.END)));\n  };\n\n  DateRangeInput.prototype.validateProps = function (props) {\n    if (props.value === null) {\n      throw new Error(Errors.DATERANGEINPUT_NULL_VALUE);\n    }\n  }; // Helpers\n  // =======\n\n\n  DateRangeInput.prototype.shouldFocusInputRef = function (isFocused, inputRef) {\n    return isFocused && inputRef !== undefined && document.activeElement !== inputRef;\n  };\n\n  DateRangeInput.prototype.isNextDateRangeValid = function (nextDate, boundary) {\n    return this.isDateValidAndInRange(nextDate) && !this.doBoundaryDatesOverlap(nextDate, boundary);\n  }; // this is a slightly kludgy function, but it saves us a good amount of repeated code between\n  // the constructor and componentDidUpdate.\n\n\n  DateRangeInput.prototype.getFormattedMinMaxDateString = function (props, propName) {\n    var date = props[propName];\n    var defaultDate = DateRangeInput_1.defaultProps[propName]; // default values are applied only if a prop is strictly `undefined`\n    // See: https://facebook.github.io/react/docs/react-component.html#defaultprops\n\n    return getFormattedDateString(date === undefined ? defaultDate : date, this.props);\n  };\n\n  DateRangeInput.prototype.parseDate = function (dateString) {\n    if (dateString === this.props.outOfRangeMessage || dateString === this.props.invalidDateMessage) {\n      return null;\n    }\n\n    var _a = this.props,\n        locale = _a.locale,\n        parseDate = _a.parseDate;\n    var newDate = parseDate(dateString, locale);\n    return newDate === false ? new Date(undefined) : newDate;\n  };\n\n  DateRangeInput.prototype.formatDate = function (date) {\n    if (!this.isDateValidAndInRange(date)) {\n      return \"\";\n    }\n\n    var _a = this.props,\n        locale = _a.locale,\n        formatDate = _a.formatDate;\n    return formatDate(date, locale);\n  };\n\n  var DateRangeInput_1;\n  DateRangeInput.defaultProps = {\n    allowSingleDayRange: false,\n    closeOnSelection: true,\n    contiguousCalendarMonths: true,\n    dayPickerProps: {},\n    disabled: false,\n    endInputProps: {},\n    invalidDateMessage: \"Invalid date\",\n    maxDate: getDefaultMaxDate(),\n    minDate: getDefaultMinDate(),\n    outOfRangeMessage: \"Out of range\",\n    overlappingDatesMessage: \"Overlapping dates\",\n    popoverProps: {},\n    selectAllOnFocus: false,\n    shortcuts: true,\n    singleMonthOnly: false,\n    startInputProps: {}\n  };\n  DateRangeInput.displayName = DISPLAYNAME_PREFIX + \".DateRangeInput\";\n  DateRangeInput = DateRangeInput_1 = __decorate([polyfill], DateRangeInput);\n  return DateRangeInput;\n}(AbstractPureComponent2);\n\nexport { DateRangeInput };","map":null,"metadata":{},"sourceType":"module"}