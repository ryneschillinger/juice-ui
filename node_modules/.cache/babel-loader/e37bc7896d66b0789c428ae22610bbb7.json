{"ast":null,"code":"/*\n * Copyright 2017 Palantir Technologies, Inc. All rights reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { __assign, __extends, __rest } from \"tslib\";\nimport classNames from \"classnames\";\nimport * as React from \"react\";\nimport { AbstractPureComponent2, Classes as CoreClasses, DISPLAYNAME_PREFIX, Keys, Popover, PopoverInteractionKind, Position, TagInput, refHandler, setRef } from \"@blueprintjs/core\";\nimport { Classes } from \"../../common\";\nimport { QueryList } from \"../query-list/queryList\";\n\nvar MultiSelect =\n/** @class */\nfunction (_super) {\n  __extends(MultiSelect, _super);\n\n  function MultiSelect() {\n    var _a;\n\n    var _this = _super.apply(this, arguments) || this;\n\n    _this.state = {\n      isOpen: _this.props.popoverProps && _this.props.popoverProps.isOpen || false\n    };\n    _this.TypedQueryList = QueryList.ofType();\n    _this.input = null;\n    _this.queryList = null;\n    _this.refHandlers = {\n      input: refHandler(_this, \"input\", (_a = _this.props.tagInputProps) === null || _a === void 0 ? void 0 : _a.inputRef),\n      queryList: function (ref) {\n        return _this.queryList = ref;\n      }\n    };\n\n    _this.renderQueryList = function (listProps) {\n      var _a;\n\n      var _b = _this.props,\n          fill = _b.fill,\n          _c = _b.tagInputProps,\n          tagInputProps = _c === void 0 ? {} : _c,\n          _d = _b.popoverProps,\n          popoverProps = _d === void 0 ? {} : _d,\n          _e = _b.selectedItems,\n          selectedItems = _e === void 0 ? [] : _e,\n          placeholder = _b.placeholder;\n      var handlePaste = listProps.handlePaste,\n          handleKeyDown = listProps.handleKeyDown,\n          handleKeyUp = listProps.handleKeyUp;\n\n      if (fill) {\n        popoverProps.fill = true;\n        tagInputProps.fill = true;\n      } // add our own inputProps.className so that we can reference it in event handlers\n\n\n      var inputProps = __assign(__assign({}, tagInputProps.inputProps), {\n        className: classNames((_a = tagInputProps.inputProps) === null || _a === void 0 ? void 0 : _a.className, Classes.MULTISELECT_TAG_INPUT_INPUT)\n      });\n\n      var handleTagInputAdd = function (values, method) {\n        if (method === \"paste\") {\n          handlePaste(values);\n        }\n      };\n\n      return (\n        /* eslint-disable-next-line deprecation/deprecation */\n        React.createElement(Popover, __assign({\n          autoFocus: false,\n          canEscapeKeyClose: true,\n          enforceFocus: false,\n          isOpen: _this.state.isOpen,\n          position: Position.BOTTOM_LEFT\n        }, popoverProps, {\n          className: classNames(listProps.className, popoverProps.className),\n          interactionKind: PopoverInteractionKind.CLICK,\n          onInteraction: _this.handlePopoverInteraction,\n          popoverClassName: classNames(Classes.MULTISELECT_POPOVER, popoverProps.popoverClassName),\n          onOpened: _this.handlePopoverOpened\n        }), React.createElement(\"div\", {\n          onKeyDown: _this.getTagInputKeyDownHandler(handleKeyDown),\n          onKeyUp: _this.getTagInputKeyUpHandler(handleKeyUp)\n        }, React.createElement(TagInput, __assign({\n          placeholder: placeholder\n        }, tagInputProps, {\n          className: classNames(Classes.MULTISELECT, tagInputProps.className),\n          inputRef: _this.refHandlers.input,\n          inputProps: inputProps,\n          inputValue: listProps.query,\n\n          /* eslint-disable-next-line react/jsx-no-bind */\n          onAdd: handleTagInputAdd,\n          onInputChange: listProps.handleQueryChange,\n          onRemove: _this.handleTagRemove,\n          values: selectedItems.map(_this.props.tagRenderer)\n        }))), React.createElement(\"div\", {\n          onKeyDown: handleKeyDown,\n          onKeyUp: handleKeyUp\n        }, listProps.itemList))\n      );\n    };\n\n    _this.handleItemSelect = function (item, evt) {\n      var _a, _b;\n\n      if (_this.input != null) {\n        _this.input.focus();\n      }\n\n      (_b = (_a = _this.props).onItemSelect) === null || _b === void 0 ? void 0 : _b.call(_a, item, evt);\n    };\n\n    _this.handleQueryChange = function (query, evt) {\n      var _a, _b;\n\n      _this.setState({\n        isOpen: query.length > 0 || !_this.props.openOnKeyDown\n      });\n\n      (_b = (_a = _this.props).onQueryChange) === null || _b === void 0 ? void 0 : _b.call(_a, query, evt);\n    }; // Popover interaction kind is CLICK, so this only handles click events.\n    // Note that we defer to the next animation frame in order to get the latest document.activeElement\n\n\n    _this.handlePopoverInteraction = function (nextOpenState, evt) {\n      return _this.requestAnimationFrame(function () {\n        var _a, _b;\n\n        var isInputFocused = _this.input === document.activeElement;\n\n        if (_this.input != null && !isInputFocused) {\n          // input is no longer focused, we should close the popover\n          _this.setState({\n            isOpen: false\n          });\n        } else if (!_this.props.openOnKeyDown) {\n          // we should open immediately on click focus events\n          _this.setState({\n            isOpen: true\n          });\n        }\n\n        (_b = (_a = _this.props.popoverProps) === null || _a === void 0 ? void 0 : _a.onInteraction) === null || _b === void 0 ? void 0 : _b.call(_a, nextOpenState, evt);\n      });\n    };\n\n    _this.handlePopoverOpened = function (node) {\n      var _a, _b;\n\n      if (_this.queryList != null) {\n        // scroll active item into view after popover transition completes and all dimensions are stable.\n        _this.queryList.scrollActiveItemIntoView();\n      }\n\n      (_b = (_a = _this.props.popoverProps) === null || _a === void 0 ? void 0 : _a.onOpened) === null || _b === void 0 ? void 0 : _b.call(_a, node);\n    };\n\n    _this.handleTagRemove = function (tag, index) {\n      var _a;\n\n      var _b = _this.props,\n          _c = _b.selectedItems,\n          selectedItems = _c === void 0 ? [] : _c,\n          onRemove = _b.onRemove,\n          tagInputProps = _b.tagInputProps;\n      onRemove === null || onRemove === void 0 ? void 0 : onRemove(selectedItems[index], index);\n      (_a = tagInputProps === null || tagInputProps === void 0 ? void 0 : tagInputProps.onRemove) === null || _a === void 0 ? void 0 : _a.call(tagInputProps, tag, index);\n    };\n\n    _this.getTagInputKeyDownHandler = function (handleQueryListKeyDown) {\n      return function (e) {\n        // HACKHACK: https://github.com/palantir/blueprint/issues/4165\n        // eslint-disable-next-line deprecation/deprecation\n        var which = e.which;\n\n        if (which === Keys.ESCAPE || which === Keys.TAB) {\n          // By default the escape key will not trigger a blur on the\n          // input element. It must be done explicitly.\n          if (_this.input != null) {\n            _this.input.blur();\n          }\n\n          _this.setState({\n            isOpen: false\n          });\n        } else if (!(which === Keys.BACKSPACE || which === Keys.ARROW_LEFT || which === Keys.ARROW_RIGHT)) {\n          _this.setState({\n            isOpen: true\n          });\n        }\n\n        var isTargetingTagRemoveButton = e.target.closest(\".\" + CoreClasses.TAG_REMOVE) != null;\n\n        if (_this.state.isOpen && !isTargetingTagRemoveButton) {\n          handleQueryListKeyDown === null || handleQueryListKeyDown === void 0 ? void 0 : handleQueryListKeyDown(e);\n        }\n      };\n    };\n\n    _this.getTagInputKeyUpHandler = function (handleQueryListKeyUp) {\n      return function (e) {\n        var isTargetingInput = e.target.classList.contains(Classes.MULTISELECT_TAG_INPUT_INPUT); // only handle events when the focus is on the actual <input> inside the TagInput, as that's\n        // what QueryList is designed to do\n\n        if (_this.state.isOpen && isTargetingInput) {\n          handleQueryListKeyUp === null || handleQueryListKeyUp === void 0 ? void 0 : handleQueryListKeyUp(e);\n        }\n      };\n    };\n\n    return _this;\n  }\n\n  MultiSelect.ofType = function () {\n    return MultiSelect;\n  };\n\n  MultiSelect.prototype.componentDidUpdate = function (prevProps) {\n    var _a, _b, _c, _d, _e;\n\n    if (((_a = prevProps.tagInputProps) === null || _a === void 0 ? void 0 : _a.inputRef) !== ((_b = this.props.tagInputProps) === null || _b === void 0 ? void 0 : _b.inputRef)) {\n      setRef((_c = prevProps.tagInputProps) === null || _c === void 0 ? void 0 : _c.inputRef, null);\n      this.refHandlers.input = refHandler(this, \"input\", (_d = this.props.tagInputProps) === null || _d === void 0 ? void 0 : _d.inputRef);\n      setRef((_e = this.props.tagInputProps) === null || _e === void 0 ? void 0 : _e.inputRef, this.input);\n    }\n  };\n\n  MultiSelect.prototype.render = function () {\n    // omit props specific to this component, spread the rest.\n    var _a = this.props,\n        openOnKeyDown = _a.openOnKeyDown,\n        popoverProps = _a.popoverProps,\n        tagInputProps = _a.tagInputProps,\n        restProps = __rest(_a, [\"openOnKeyDown\", \"popoverProps\", \"tagInputProps\"]);\n\n    return React.createElement(this.TypedQueryList, __assign({}, restProps, {\n      onItemSelect: this.handleItemSelect,\n      onQueryChange: this.handleQueryChange,\n      ref: this.refHandlers.queryList,\n      renderer: this.renderQueryList\n    }));\n  };\n\n  MultiSelect.displayName = DISPLAYNAME_PREFIX + \".MultiSelect\";\n  MultiSelect.defaultProps = {\n    fill: false,\n    placeholder: \"Search...\"\n  };\n  return MultiSelect;\n}(AbstractPureComponent2);\n\nexport { MultiSelect };","map":null,"metadata":{},"sourceType":"module"}