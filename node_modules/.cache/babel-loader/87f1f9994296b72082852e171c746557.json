{"ast":null,"code":"/*\n * Copyright 2021 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { __spreadArrays } from \"tslib\";\nimport * as React from \"react\";\nimport { comboMatches, getKeyCombo, parseKeyCombo } from \"../../components/hotkeys/hotkeyParser\";\nimport { HotkeysContext } from \"../../context\";\n/**\n * React hook to register global and local hotkeys for a component.\n *\n * @param keys list of hotkeys to configure\n * @param options hook options\n */\n\nexport function useHotkeys(keys, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var _a = options.document,\n      document = _a === void 0 ? getDefaultDocument() : _a,\n      _b = options.showDialogKeyCombo,\n      showDialogKeyCombo = _b === void 0 ? \"?\" : _b;\n  var localKeys = React.useMemo(function () {\n    return keys.filter(function (k) {\n      return !k.global;\n    }).map(function (k) {\n      return {\n        combo: parseKeyCombo(k.combo),\n        config: k\n      };\n    });\n  }, [keys]);\n  var globalKeys = React.useMemo(function () {\n    return keys.filter(function (k) {\n      return k.global;\n    }).map(function (k) {\n      return {\n        combo: parseKeyCombo(k.combo),\n        config: k\n      };\n    });\n  }, [keys]); // register keys with global context\n\n  var _c = React.useContext(HotkeysContext),\n      dispatch = _c[1];\n\n  React.useEffect(function () {\n    var payload = __spreadArrays(globalKeys.map(function (k) {\n      return k.config;\n    }), localKeys.map(function (k) {\n      return k.config;\n    }));\n\n    dispatch({\n      type: \"ADD_HOTKEYS\",\n      payload: payload\n    });\n    return function () {\n      return dispatch({\n        type: \"REMOVE_HOTKEYS\",\n        payload: payload\n      });\n    };\n  }, [keys]);\n\n  var invokeNamedCallbackIfComboRecognized = function (global, combo, callbackName, e) {\n    var _a, _b;\n\n    var isTextInput = isTargetATextInput(e);\n\n    for (var _i = 0, _c = global ? globalKeys : localKeys; _i < _c.length; _i++) {\n      var key = _c[_i];\n      var _d = key.config,\n          _e = _d.allowInInput,\n          allowInInput = _e === void 0 ? false : _e,\n          _f = _d.disabled,\n          disabled = _f === void 0 ? false : _f,\n          _g = _d.preventDefault,\n          preventDefault = _g === void 0 ? false : _g,\n          _h = _d.stopPropagation,\n          stopPropagation = _h === void 0 ? false : _h;\n      var shouldIgnore = isTextInput && !allowInInput || disabled;\n\n      if (!shouldIgnore && comboMatches(key.combo, combo)) {\n        if (preventDefault) {\n          e.preventDefault();\n        }\n\n        if (stopPropagation) {\n          // set a flag just for unit testing. not meant to be referenced in feature work.\n          e.isPropagationStopped = true;\n          e.stopPropagation();\n        }\n\n        (_b = (_a = key.config)[callbackName]) === null || _b === void 0 ? void 0 : _b.call(_a, e);\n      }\n    }\n  };\n\n  var handleGlobalKeyDown = React.useCallback(function (e) {\n    // special case for global keydown: if '?' is pressed, open the hotkeys dialog\n    var combo = getKeyCombo(e);\n    var isTextInput = isTargetATextInput(e);\n\n    if (!isTextInput && comboMatches(parseKeyCombo(showDialogKeyCombo), combo)) {\n      dispatch({\n        type: \"OPEN_DIALOG\"\n      });\n    } else {\n      invokeNamedCallbackIfComboRecognized(true, getKeyCombo(e), \"onKeyDown\", e);\n    }\n  }, [globalKeys]);\n  var handleGlobalKeyUp = React.useCallback(function (e) {\n    return invokeNamedCallbackIfComboRecognized(true, getKeyCombo(e), \"onKeyUp\", e);\n  }, [globalKeys]);\n  var handleLocalKeyDown = React.useCallback(function (e) {\n    return invokeNamedCallbackIfComboRecognized(false, getKeyCombo(e.nativeEvent), \"onKeyDown\", e.nativeEvent);\n  }, [localKeys]);\n  var handleLocalKeyUp = React.useCallback(function (e) {\n    return invokeNamedCallbackIfComboRecognized(false, getKeyCombo(e.nativeEvent), \"onKeyUp\", e.nativeEvent);\n  }, [localKeys]);\n  React.useEffect(function () {\n    // document is guaranteed to be defined inside effects\n    document.addEventListener(\"keydown\", handleGlobalKeyDown);\n    document.addEventListener(\"keyup\", handleGlobalKeyUp);\n    return function () {\n      document.removeEventListener(\"keydown\", handleGlobalKeyDown);\n      document.removeEventListener(\"keyup\", handleGlobalKeyUp);\n    };\n  }, [handleGlobalKeyDown, handleGlobalKeyUp]);\n  return {\n    handleKeyDown: handleLocalKeyDown,\n    handleKeyUp: handleLocalKeyUp\n  };\n}\n/**\n * @returns true if the event target is a text input which should take priority over hotkey bindings\n */\n\nfunction isTargetATextInput(e) {\n  var elem = e.target; // we check these cases for unit testing, but this should not happen\n  // during normal operation\n\n  if (elem == null || elem.closest == null) {\n    return false;\n  }\n\n  var editable = elem.closest(\"input, textarea, [contenteditable=true]\");\n\n  if (editable == null) {\n    return false;\n  } // don't let checkboxes, switches, and radio buttons prevent hotkey behavior\n\n\n  if (editable.tagName.toLowerCase() === \"input\") {\n    var inputType = editable.type;\n\n    if (inputType === \"checkbox\" || inputType === \"radio\") {\n      return false;\n    }\n  } // don't let read-only fields prevent hotkey behavior\n\n\n  if (editable.readOnly) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction getDefaultDocument() {\n  if (typeof window === \"undefined\") {\n    return undefined;\n  }\n\n  return window.document;\n}","map":null,"metadata":{},"sourceType":"module"}